(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/platform-browser'), require('rxjs/ReplaySubject')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/common', '@angular/platform-browser', 'rxjs/ReplaySubject'], factory) :
	(factory((global.ng = global.ng || {}, global.ng['ngx-scroll-to'] = {}),global.ng.core,global.ng.common,global.ng.platformBrowser,global.Rx));
}(this, (function (exports,_angular_core,_angular_common,_angular_platformBrowser,rxjs_ReplaySubject) { 'use strict';

/**
 * Default values for Component Input.
 */
var DEFAULTS = {
    target: null,
    event: 'click',
    duration: 650,
    easing: 'easeInOutQuad',
    offset: 0,
    offsetMap: new Map()
};
/**
 * Easing Colleciton.
 */
var EASING = {
    easeInQuad: function (time) {
        return time * time;
    },
    easeOutQuad: function (time) {
        return time * (2 - time);
    },
    easeInOutQuad: function (time) {
        return time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time;
    },
    easeInCubic: function (time) {
        return time * time * time;
    },
    easeOutCubic: function (time) {
        return (--time) * time * time + 1;
    },
    easeInOutCubic: function (time) {
        return time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;
    },
    easeInQuart: function (time) {
        return time * time * time * time;
    },
    easeOutQuart: function (time) {
        return 1 - (--time) * time * time * time;
    },
    easeInOutQuart: function (time) {
        return time < 0.5 ? 8 * time * time * time * time : 1 - 8 * (--time) * time * time * time;
    },
    easeInQuint: function (time) {
        return time * time * time * time * time;
    },
    easeOutQuint: function (time) {
        return 1 + (--time) * time * time * time * time;
    },
    easeInOutQuint: function (time) {
        return time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * (--time) * time * time * time * time;
    },
    easeOutElastic: function (time) {
        return Math.pow(2, -10 * time) * Math.sin((time - 1 / 4) * (2 * Math.PI) / 1) + 1;
    }
};
var EVENTS = [
    'click',
    'mouseenter',
    'mouseover',
    'mousedown',
    'mouseup',
    'dblclick',
    'contextmenu',
    'wheel',
    'mouseleave',
    'mouseout'
];
/**
 * Merge user config with default config.
 *
 * @param config 				User Configuration Object
 * @returns 					Merged Configuration Object
 */
function mergeConfigWithDefaults(config) {
    var filtered = {};
    Object.keys(config)
        .filter(function (key) { return config[key] !== undefined; })
        .forEach(function (key) { return filtered[key] = config[key]; });
    return Object.assign({}, DEFAULTS, filtered);
}
/**
 * Strip hash (#) from value.
 *
 * @param value 				The given string value
 * @returns 					The stripped string value
 */
function stripHash(value) {
    return value.substring(0, 1) === '#' ? value.substring(1) : value;
}
/**
 * Test if a given value is a string.
 *
 * @param value 					The given value
 * @returns 						Whether the given value is a string
 */
function isString(value) {
    return typeof value === 'string' || value instanceof String;
}
/**
 * Test if a given Element is the Window.
 *
 * @param container 				The given Element
 * @returns 						Whether the given Element is Window
 */
function isWindow(container) {
    return container === window;
}
/**
 * Test if a given value is of type ElementRef.
 *
 * @param value 					The given value
 * @returns 						Whether the given value is a number
 */
function isElementRef(value) {
    return value instanceof _angular_core.ElementRef;
}
/**
 * Test if a given value is type number.
 *
 * @param value 					The given value
 * @returns 						Whether the given value is a number
 */
function isNumber(value) {
    return !isNaN(parseFloat(value)) && isFinite(value);
}

function TimeOut(ms) {
    if (ms === void 0) { ms = 0; }
    return function (target, key, descriptor) {
        var originalMethod = descriptor.value;
        descriptor.value = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            setTimeout(function () { return originalMethod.apply(_this, args); }, ms);
        };
        return descriptor;
    };
}

var ScrollToAnimation = (function () {
    function ScrollToAnimation(_container, _listenerTarget, _is_window, _to, _options, _is_browser) {
        var _this = this;
        this._container = _container;
        this._listenerTarget = _listenerTarget;
        this._is_window = _is_window;
        this._to = _to;
        this._options = _options;
        this._is_browser = _is_browser;
        /**
         * Recursively loop over the Scroll Animation.
         *
         * @returns void
         */
        this._loop = function () {
            _this._time_lapsed += _this._tick;
            _this._percentage = (_this._time_lapsed / _this._options.duration);
            _this._percentage = (_this._percentage > 1) ? 1 : _this._percentage;
            _this._position = _this._start_position
                + ((_this._start_position - _this._to < 0 ? 1 : -1) * _this._distance * EASING[_this._options.easing](_this._percentage));
            _this._source$.next(_this._position);
            _this._is_window ? _this._listenerTarget.scrollTo(0, Math.floor(_this._position)) : _this._container.scrollTop = Math.floor(_this._position);
            _this.stop(false);
        };
        this._tick = 16;
        this._interval = null;
        this._time_lapsed = 0;
        this._windowScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        this._start_position = this._is_window ? this._windowScrollTop : this._container.scrollTop;
        // Correction for Starting Position of nested HTML Elements
        if (!this._is_window)
            this._to = this._to - this._container.getBoundingClientRect().top + this._start_position;
        // Set Distance
        this._distance = Math.abs(this._start_position - this._to);
        var offset = this._options.offset;
        // Set offset from Offset Map
        if (this._is_browser) {
            this._options
                .offsetMap
                .forEach(function (value, key) { return offset = window.innerWidth > key ? value : offset; });
        }
        this._distance += offset;
        this._source$ = new rxjs_ReplaySubject.ReplaySubject();
    }
    /**
     * Start the new Scroll Animation.
     *
     * @todo consider using enums for actiontypes
     *
     * @returns void
     */
    ScrollToAnimation.prototype.start = function () {
        clearInterval(this._interval);
        this._interval = setInterval(this._loop, this._tick);
        return this._source$.asObservable();
    };
    /**
     * Stop the current Scroll Animation Loop.
     *
     * @param force 			Force to stop
     */
    ScrollToAnimation.prototype.stop = function (force) {
        if (force === void 0) { force = true; }
        var curr_position = this._is_window ? this._windowScrollTop : this._container.scrollTop;
        if (force || this._position === (this._to + this._options.offset) || curr_position === (this._to + this._options.offset)) {
            clearInterval(this._interval);
            this._interval = null;
            this._source$.complete();
        }
    };
    return ScrollToAnimation;
}());

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ScrollToService = (function () {
    function ScrollToService(_document, _platform_id) {
        this._document = _document;
        this._platform_id = _platform_id;
    }
    /**
     * Target an Element to scroll to.
     *
     * @todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:
     * 	- https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481
     *
     * @param event 				Native Browser Event
     * @param config 				Configuration Object
     * @returns 					Observable
     */
    ScrollToService.prototype.scrollTo = function (event, config) {
        if (!_angular_common.isPlatformBrowser(this._platform_id))
            return new rxjs_ReplaySubject.ReplaySubject().asObservable();
        return this._start(event, config);
    };
    /**
     * Start a new Animation.
     *
     * @todo Emit proper events from subscription
     *
     * @param event 				Native Browser Event
     * @param config 				Configuration Object
     * @returns 					Observable
     */
    ScrollToService.prototype._start = function (event, config) {
        var _this = this;
        // Merge config with default values
        var merged_config = mergeConfigWithDefaults(config);
        if (this._animation)
            this._animation.stop();
        var container = this._getFirstScrollableParent(event.target);
        var target_node = this._getTargetNode(merged_config.target);
        var listenerTarget = this._getListenerTarget(container);
        var is_window = isWindow(listenerTarget);
        var to = is_window ? target_node.offsetTop : target_node.getBoundingClientRect().top;
        // Create Animation
        this._animation = new ScrollToAnimation(container, listenerTarget, is_window, to, merged_config, _angular_common.isPlatformBrowser(this._platform_id));
        var stop_events = ['mousewheel', 'DOMMouseScroll', 'touchstart'];
        var stop_event_handler = function () { return _this._animation.stop(); };
        // Add Stop Event Listeners
        this._addStopEventListeners(stop_events, listenerTarget, stop_event_handler);
        // Start Animation
        var animation$ = this._animation.start();
        var subscription = animation$
            .subscribe(function () { }, function () { }, function () {
            _this._removeStopEventListeners(stop_events, listenerTarget, stop_event_handler);
            subscription.unsubscribe();
        });
        return animation$;
    };
    /**
     * Add listeners for the Animation Stop Event.
     *
     * @param events 					List of events to listen to
     * @param listenerTarget 			Target to attach the listener on
     * @param handler 					Handler for when the listener fires
     * @returns void
     */
    ScrollToService.prototype._addStopEventListeners = function (events, listenerTarget, handler) {
        events.forEach(function (event) { return listenerTarget.addEventListener(event, handler); });
    };
    /**
     * Remove listeners for the Animation Stop Event.
     *
     * @param events 					List of events to listen to
     * @param listenerTarget 			Target to attach the listener on
     * @param handler 					Handler for when the listener fires
     * @returns void
     */
    ScrollToService.prototype._removeStopEventListeners = function (events, listenerTarget, handler) {
        events.forEach(function (event) { return listenerTarget.removeEventListener(event, handler); });
    };
    /**
     * Find the first scrollable parent node of an element.
     *
     * @param nativeElement 			The element to search from
     * @return 							The first scrollable parent element
     */
    ScrollToService.prototype._getFirstScrollableParent = function (nativeElement) {
        var style = window.getComputedStyle(nativeElement);
        var overflow_regex = /(auto|scroll)/;
        if (style.position === 'fixed')
            throw new Error("Scroll item cannot be positioned 'fixed'");
        // Recursive Loop Parents
        for (var parent_1 = nativeElement; parent_1 = parent_1.parentElement; null) {
            // Recalculate Style
            style = window.getComputedStyle(parent_1);
            // Skip Absolute Positioning
            if (style.position === 'absolute')
                continue;
            // Skip Hidden Overflow
            if (style.overflow === 'hidden' || style.overflowY === 'hidden')
                continue;
            // Test Overflow
            if (overflow_regex.test(style.overflow + style.overflowY + style.overflowX))
                return parent_1;
            // Return Body
            if (parent_1.tagName === 'BODY')
                return parent_1;
        }
        throw new Error("No scrollable parent found for element " + nativeElement.nodeName);
    };
    /**
     * Get the Target Node to scroll to.
     *
     * @param id 			The given ID of the node, either a string or an element reference
     * @returns 			Target Node
     */
    ScrollToService.prototype._getTargetNode = function (id) {
        var target_node;
        if (isString(id)) {
            target_node = this._document.getElementById(stripHash(id));
        }
        else if (isNumber(id)) {
            target_node = this._document.getElementById(String(id));
        }
        else if (isElementRef(id)) {
            target_node = id.nativeElement;
        }
        if (!target_node)
            throw new Error('Unable to find Target Element');
        return target_node;
    };
    /**
     * Retrieve the Listener target.
     *
     * @param container 				The HTML Container element
     * @returns 						Listener
     */
    ScrollToService.prototype._getListenerTarget = function (container) {
        return container.tagName.toUpperCase() === 'BODY' ? window : container;
    };
    ScrollToService.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ScrollToService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.PLATFORM_ID,] },] },
    ]; };
    __decorate([
        TimeOut()
    ], ScrollToService.prototype, "scrollTo", null);
    return ScrollToService;
}());

var ScrollToDirective = (function () {
    function ScrollToDirective(_elementRef, _scrollToService, _renderer2) {
        this._elementRef = _elementRef;
        this._scrollToService = _scrollToService;
        this._renderer2 = _renderer2;
        this.ngxScrollTo = DEFAULTS.target;
        this.ngxScrollToEvent = DEFAULTS.event;
        this.ngxScrollToDuration = DEFAULTS.duration;
        this.ngxScrollToEasing = DEFAULTS.easing;
        this.ngxScrollToOffset = DEFAULTS.offset;
        this.ngxScrollToOffsetMap = DEFAULTS.offsetMap;
    }
    /**
     * Angular Lifecycle Hook - After View Init
     *
     * @todo Implement Subscription for Events
     *
     * @returns void
     */
    ScrollToDirective.prototype.ngAfterViewInit = function () {
        var _this = this;
        // Test Event Support
        if (!EVENTS.includes(this.ngxScrollToEvent))
            throw new Error("Unsupported Event '" + this.ngxScrollToEvent + "'");
        // Listen for the trigger...
        this._renderer2.listen(this._elementRef.nativeElement, this.ngxScrollToEvent, function (event) {
            _this._config = {
                target: _this.ngxScrollTo,
                duration: _this.ngxScrollToDuration,
                easing: _this.ngxScrollToEasing,
                offset: _this.ngxScrollToOffset,
                offsetMap: _this.ngxScrollToOffsetMap
            };
            _this._scrollToService.scrollTo(event, _this._config);
        });
    };
    ScrollToDirective.decorators = [
        { type: _angular_core.Directive, args: [{
                    selector: '[ngx-scroll-to]'
                },] },
    ];
    /** @nocollapse */
    ScrollToDirective.ctorParameters = function () { return [
        { type: _angular_core.ElementRef, },
        { type: ScrollToService, },
        { type: _angular_core.Renderer2, },
    ]; };
    ScrollToDirective.propDecorators = {
        'ngxScrollTo': [{ type: _angular_core.Input, args: ['ngx-scroll-to',] },],
        'ngxScrollToEvent': [{ type: _angular_core.Input, args: ['ngx-scroll-to-event',] },],
        'ngxScrollToDuration': [{ type: _angular_core.Input, args: ['ngx-scroll-to-duration',] },],
        'ngxScrollToEasing': [{ type: _angular_core.Input, args: ['ngx-scroll-to-easing',] },],
        'ngxScrollToOffset': [{ type: _angular_core.Input, args: ['ngx-scroll-to-offset',] },],
        'ngxScrollToOffsetMap': [{ type: _angular_core.Input, args: ['ngx-scroll-to-offset-map',] },],
    };
    return ScrollToDirective;
}());

var ScrollToModule = (function () {
    function ScrollToModule() {
    }
    /**
     * Guaranteed singletons for provided Services across App.
     *
     * @return 				An Angular Module with Providers
     */
    ScrollToModule.forRoot = function () {
        return {
            ngModule: ScrollToModule,
            providers: [
                ScrollToService
            ]
        };
    };
    ScrollToModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    imports: [
                        _angular_common.CommonModule
                    ],
                    declarations: [
                        ScrollToDirective
                    ],
                    exports: [
                        ScrollToDirective
                    ]
                },] },
    ];
    /** @nocollapse */
    ScrollToModule.ctorParameters = function () { return []; };
    return ScrollToModule;
}());

exports.ScrollToModule = ScrollToModule;
exports.ScrollToService = ScrollToService;

Object.defineProperty(exports, '__esModule', { value: true });

})));
