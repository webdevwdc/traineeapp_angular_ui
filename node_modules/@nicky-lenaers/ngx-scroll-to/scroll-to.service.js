var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Injectable, PLATFORM_ID, Inject } from '@angular/core';
import { DOCUMENT } from '@angular/platform-browser';
import { isPlatformBrowser } from '@angular/common';
import { ReplaySubject } from 'rxjs/ReplaySubject';
import { TimeOut } from './decorators/scroll-to-timeout.decorator';
import { ScrollToAnimation } from './statics/scroll-to-animation';
import { stripHash, isString, isNumber, isElementRef, isWindow, mergeConfigWithDefaults } from './statics/scroll-to-helpers';
var ScrollToService = (function () {
    function ScrollToService(_document, _platform_id) {
        this._document = _document;
        this._platform_id = _platform_id;
    }
    /**
     * Target an Element to scroll to.
     *
     * @todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:
     * 	- https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481
     *
     * @param event 				Native Browser Event
     * @param config 				Configuration Object
     * @returns 					Observable
     */
    ScrollToService.prototype.scrollTo = function (event, config) {
        if (!isPlatformBrowser(this._platform_id))
            return new ReplaySubject().asObservable();
        return this._start(event, config);
    };
    /**
     * Start a new Animation.
     *
     * @todo Emit proper events from subscription
     *
     * @param event 				Native Browser Event
     * @param config 				Configuration Object
     * @returns 					Observable
     */
    ScrollToService.prototype._start = function (event, config) {
        var _this = this;
        // Merge config with default values
        var merged_config = mergeConfigWithDefaults(config);
        if (this._animation)
            this._animation.stop();
        var container = this._getFirstScrollableParent(event.target);
        var target_node = this._getTargetNode(merged_config.target);
        var listenerTarget = this._getListenerTarget(container);
        var is_window = isWindow(listenerTarget);
        var to = is_window ? target_node.offsetTop : target_node.getBoundingClientRect().top;
        // Create Animation
        this._animation = new ScrollToAnimation(container, listenerTarget, is_window, to, merged_config, isPlatformBrowser(this._platform_id));
        var stop_events = ['mousewheel', 'DOMMouseScroll', 'touchstart'];
        var stop_event_handler = function () { return _this._animation.stop(); };
        // Add Stop Event Listeners
        this._addStopEventListeners(stop_events, listenerTarget, stop_event_handler);
        // Start Animation
        var animation$ = this._animation.start();
        var subscription = animation$
            .subscribe(function () { }, function () { }, function () {
            _this._removeStopEventListeners(stop_events, listenerTarget, stop_event_handler);
            subscription.unsubscribe();
        });
        return animation$;
    };
    /**
     * Add listeners for the Animation Stop Event.
     *
     * @param events 					List of events to listen to
     * @param listenerTarget 			Target to attach the listener on
     * @param handler 					Handler for when the listener fires
     * @returns void
     */
    ScrollToService.prototype._addStopEventListeners = function (events, listenerTarget, handler) {
        events.forEach(function (event) { return listenerTarget.addEventListener(event, handler); });
    };
    /**
     * Remove listeners for the Animation Stop Event.
     *
     * @param events 					List of events to listen to
     * @param listenerTarget 			Target to attach the listener on
     * @param handler 					Handler for when the listener fires
     * @returns void
     */
    ScrollToService.prototype._removeStopEventListeners = function (events, listenerTarget, handler) {
        events.forEach(function (event) { return listenerTarget.removeEventListener(event, handler); });
    };
    /**
     * Find the first scrollable parent node of an element.
     *
     * @param nativeElement 			The element to search from
     * @return 							The first scrollable parent element
     */
    ScrollToService.prototype._getFirstScrollableParent = function (nativeElement) {
        var style = window.getComputedStyle(nativeElement);
        var overflow_regex = /(auto|scroll)/;
        if (style.position === 'fixed')
            throw new Error("Scroll item cannot be positioned 'fixed'");
        // Recursive Loop Parents
        for (var parent_1 = nativeElement; parent_1 = parent_1.parentElement; null) {
            // Recalculate Style
            style = window.getComputedStyle(parent_1);
            // Skip Absolute Positioning
            if (style.position === 'absolute')
                continue;
            // Skip Hidden Overflow
            if (style.overflow === 'hidden' || style.overflowY === 'hidden')
                continue;
            // Test Overflow
            if (overflow_regex.test(style.overflow + style.overflowY + style.overflowX))
                return parent_1;
            // Return Body
            if (parent_1.tagName === 'BODY')
                return parent_1;
        }
        throw new Error("No scrollable parent found for element " + nativeElement.nodeName);
    };
    /**
     * Get the Target Node to scroll to.
     *
     * @param id 			The given ID of the node, either a string or an element reference
     * @returns 			Target Node
     */
    ScrollToService.prototype._getTargetNode = function (id) {
        var target_node;
        if (isString(id)) {
            target_node = this._document.getElementById(stripHash(id));
        }
        else if (isNumber(id)) {
            target_node = this._document.getElementById(String(id));
        }
        else if (isElementRef(id)) {
            target_node = id.nativeElement;
        }
        if (!target_node)
            throw new Error('Unable to find Target Element');
        return target_node;
    };
    /**
     * Retrieve the Listener target.
     *
     * @param container 				The HTML Container element
     * @returns 						Listener
     */
    ScrollToService.prototype._getListenerTarget = function (container) {
        return container.tagName.toUpperCase() === 'BODY' ? window : container;
    };
    ScrollToService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    ScrollToService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
        { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] },] },
    ]; };
    __decorate([
        TimeOut()
    ], ScrollToService.prototype, "scrollTo", null);
    return ScrollToService;
}());
export { ScrollToService };
//# sourceMappingURL=scroll-to.service.js.map