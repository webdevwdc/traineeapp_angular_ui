import { ReplaySubject } from 'rxjs/ReplaySubject';
import { EASING } from '../statics/scroll-to-helpers';
var ScrollToAnimation = (function () {
    function ScrollToAnimation(_container, _listenerTarget, _is_window, _to, _options, _is_browser) {
        var _this = this;
        this._container = _container;
        this._listenerTarget = _listenerTarget;
        this._is_window = _is_window;
        this._to = _to;
        this._options = _options;
        this._is_browser = _is_browser;
        /**
         * Recursively loop over the Scroll Animation.
         *
         * @returns void
         */
        this._loop = function () {
            _this._time_lapsed += _this._tick;
            _this._percentage = (_this._time_lapsed / _this._options.duration);
            _this._percentage = (_this._percentage > 1) ? 1 : _this._percentage;
            _this._position = _this._start_position
                + ((_this._start_position - _this._to < 0 ? 1 : -1) * _this._distance * EASING[_this._options.easing](_this._percentage));
            _this._source$.next(_this._position);
            _this._is_window ? _this._listenerTarget.scrollTo(0, Math.floor(_this._position)) : _this._container.scrollTop = Math.floor(_this._position);
            _this.stop(false);
        };
        this._tick = 16;
        this._interval = null;
        this._time_lapsed = 0;
        this._windowScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        this._start_position = this._is_window ? this._windowScrollTop : this._container.scrollTop;
        // Correction for Starting Position of nested HTML Elements
        if (!this._is_window)
            this._to = this._to - this._container.getBoundingClientRect().top + this._start_position;
        // Set Distance
        this._distance = Math.abs(this._start_position - this._to);
        var offset = this._options.offset;
        // Set offset from Offset Map
        if (this._is_browser) {
            this._options
                .offsetMap
                .forEach(function (value, key) { return offset = window.innerWidth > key ? value : offset; });
        }
        this._distance += offset;
        this._source$ = new ReplaySubject();
    }
    /**
     * Start the new Scroll Animation.
     *
     * @todo consider using enums for actiontypes
     *
     * @returns void
     */
    ScrollToAnimation.prototype.start = function () {
        clearInterval(this._interval);
        this._interval = setInterval(this._loop, this._tick);
        return this._source$.asObservable();
    };
    /**
     * Stop the current Scroll Animation Loop.
     *
     * @param force 			Force to stop
     */
    ScrollToAnimation.prototype.stop = function (force) {
        if (force === void 0) { force = true; }
        var curr_position = this._is_window ? this._windowScrollTop : this._container.scrollTop;
        if (force || this._position === (this._to + this._options.offset) || curr_position === (this._to + this._options.offset)) {
            clearInterval(this._interval);
            this._interval = null;
            this._source$.complete();
        }
    };
    return ScrollToAnimation;
}());
export { ScrollToAnimation };
//# sourceMappingURL=scroll-to-animation.js.map