"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var cluster_placement_mode_1 = require("../models/cluster-placement-mode");
var cluster_click_action_1 = require("../models/cluster-click-action");
var cluster_service_1 = require("../services/cluster.service");
var map_layer_1 = require("./map-layer");
/**
 *
 * Creates a cluster layer on a {@link MapComponent}.
 *
 * ### Example
 * ```typescript
 * import {Component} from '@angular/core';
 * import {MapComponent, MapMarkerDirective} from '...';
 *
 * @Component({
 *  selector: 'my-map-cmp',
 *  styles: [`
 *   .map-container {
 *     height: 300px;
 *   }
 * `],
 * template: `
 *   <x-map [Latitude]='lat' [Longitude]='lng' [Zoom]='zoom'>
 *     <x-cluster-layer [Visible]='visible'>
 *         <x-map-marker [Latitude]='lat' [Longitude]='lng' [Label]=''M''></x-map-marker>
 *     </x-cluster-layer>
 *   </x-map>
 * `
 * })
 * ```
 *
 * @export
 * @class ClusterLayerDirective
 * @extends {MapLayerDirective}
 * @implements {OnInit}
 * @implements {OnDestroy}
 * @implements {OnChanges}
 */
var ClusterLayerDirective = (function (_super) {
    __extends(ClusterLayerDirective, _super);
    ///
    /// Constructor
    ///
    /**
     * Creates an instance of ClusterLayerDirective.
     *
     * @param {ClusterService} _layerService - Concreted implementation of a cluster layer service for the underlying maps
     * implementations. Generally provided via injections.
     * @param {ViewContainerRef} _containerRef - A reference to the view container of the layer. Generally provided via injection.
     *
     * @memberof ClusterLayerDirective
     */
    function ClusterLayerDirective(_layerService, _containerRef) {
        var _this = _super.call(this, _layerService, _containerRef) || this;
        ///
        /// Field declarations
        ///
        _this._averageCenter = false;
        _this._clusteringEnabled = true;
        _this._clusterPlacementMode = cluster_placement_mode_1.ClusterPlacementMode.MeanValue;
        _this._clusterClickAction = cluster_click_action_1.ClusterClickAction.ZoomIntoCluster;
        _this._useDynamicSizeMarker = false;
        _this._dynamicMarkerBaseSize = 18;
        _this._dynamicMarkerRanges = new Map([
            [10, 'rgba(255, 40, 40, 0.5)'],
            [100, 'rgba(20, 180, 20, 0.5)'],
            [Number.MAX_SAFE_INTEGER, 'rgba(255, 210, 40, 0.5)']
        ]);
        _this._zoomOnClick = true;
        return _this;
    }
    Object.defineProperty(ClusterLayerDirective.prototype, "AverageCenter", {
        ///
        /// Property defintions
        ///
        /**
         * Gets or sets the average center of the cluster
         *
         * @type {AverageCenter}
         * @memberof ClusterLayerDirective
         */
        get: function () { return this._averageCenter; },
        set: function (val) { this._averageCenter = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClusterLayerDirective.prototype, "ClusterClickAction", {
        /**
         * Gets or sets the the Cluster Click Action {@link ClusterClickAction}.
         *
         * @type {ClusterClickAction}
         * @memberof ClusterLayerDirective
         */
        get: function () { return this._clusterClickAction; },
        set: function (val) { this._clusterClickAction = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClusterLayerDirective.prototype, "ClusteringEnabled", {
        /**
         * Gets or sets whether the clustering layer enables clustering. When set to false, the layer
         * behaves like a generic layer. This is handy if you want to prevent clustering at certain zoom levels.
         *
         * @type {boolean}
         * @memberof ClusterLayerDirective
         */
        get: function () { return this._clusteringEnabled; },
        set: function (val) { this._clusteringEnabled = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClusterLayerDirective.prototype, "ClusterPlacementMode", {
        /**
         * Gets or sets the cluster placement mode. {@link ClusterPlacementMode}
         *
         * @type {ClusterPlacementMode}
         * @memberof ClusterLayerDirective
         */
        get: function () { return this._clusterPlacementMode; },
        set: function (val) { this._clusterPlacementMode = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClusterLayerDirective.prototype, "CustomMarkerCallback", {
        /**
         * Gets or sets the callback invoked to create a custom cluster marker. Note that when {@link UseDynamicSizeMarkers} is enabled,
         * you cannot set a custom marker callback.
         *
         * @type (Array<Marker>, IMarkerIconInfo) => string
         * @memberof ClusterLayerDirective
         */
        get: function () { return this._iconCreationCallback; },
        set: function (val) {
            if (this._useDynamicSizeMarker) {
                throw (new Error("You cannot set a custom marker callback when UseDynamicSizeMarkers is set to true.\n                    Set UseDynamicSizeMakers to false."));
            }
            this._iconCreationCallback = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClusterLayerDirective.prototype, "DynamicMarkerBaseSize", {
        /**
         * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.
         * See {@link UseDynamicSizeMarkers}.
         *
         * @type {number}
         * @memberof ClusterLayerDirective
         */
        get: function () { return this._dynamicMarkerBaseSize; },
        set: function (val) { this._dynamicMarkerBaseSize = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClusterLayerDirective.prototype, "DynamicMarkerRanges", {
        /**
         * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.
         * The map contains key/value pairs, with the keys being
         * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {@link UseDynamicSizeMarkers}.
         *
         * @type {Map<number, string>}
         * @memberof ClusterLayerDirective
         */
        get: function () { return this._dynamicMarkerRanges; },
        set: function (val) { this._dynamicMarkerRanges = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClusterLayerDirective.prototype, "GridSize", {
        /**
         * Gets or sets the grid size to be used for clustering.
         *
         * @type {number}
         * @memberof ClusterLayerDirective
         */
        get: function () { return this._gridSize; },
        set: function (val) { this._gridSize = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClusterLayerDirective.prototype, "IconInfo", {
        /**
         * Gets or sets the IconInfo to be used to create a custom cluster marker. Supports font-based, SVG, graphics and more.
         * See {@link IMarkerIconInfo}.
         *
         * @type {IMarkerIconInfo}
         * @memberof ClusterLayerDirective
         */
        get: function () { return this._iconInfo; },
        set: function (val) { this._iconInfo = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClusterLayerDirective.prototype, "LayerOffset", {
        /**
         * Gets or sets An offset applied to the positioning of the layer.
         *
         * @type {IPoint}
         * @memberof ClusterLayerDirective
         */
        get: function () { return this._layerOffset; },
        set: function (val) { this._layerOffset = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClusterLayerDirective.prototype, "MinimumClusterSize", {
        /**
         * Gets or sets the minimum pins required to form a cluster
         *
         * @readonly
         * @type {number}
         * @memberof ClusterLayerDirective
         */
        get: function () { return this._minimumClusterSize; },
        set: function (val) { this._minimumClusterSize = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClusterLayerDirective.prototype, "SpiderClusterOptions", {
        /**
         * Gets or sets the options for spider clustering behavior. See {@link ISpiderClusterOptions}
         *
         * @type {ISpiderClusterOptions}
         * @memberof ClusterLayerDirective
         */
        get: function () { return this._spiderClusterOptions; },
        set: function (val) { this._spiderClusterOptions = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClusterLayerDirective.prototype, "Styles", {
        /**
         * Gets or sets the cluster styles
         *
         * @readonly
         * @type {Array<IClusterIconInfo>)}
         * @memberof ClusterLayerDirective
         */
        get: function () { return this._styles; },
        set: function (val) { this._styles = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClusterLayerDirective.prototype, "UseDynamicSizeMarkers", {
        /**
         * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of
         * pins in the cluster. If set to true, this will take precendence over any custom marker creation.
         *
         * @type {boolean}
         * @memberof ClusterLayerDirective
         */
        get: function () { return this._useDynamicSizeMarker; },
        set: function (val) {
            var _this = this;
            this._useDynamicSizeMarker = val;
            if (val) {
                this._iconCreationCallback = function (m, info) {
                    return ClusterLayerDirective.CreateDynamicSizeMarker(m.length, info, _this._dynamicMarkerBaseSize, _this._dynamicMarkerRanges);
                };
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClusterLayerDirective.prototype, "ZIndex", {
        /**
         * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.
         *
         * @type {number}
         * @memberof ClusterLayerDirective
         */
        get: function () { return this._zIndex; },
        set: function (val) { this._zIndex = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClusterLayerDirective.prototype, "ZoomOnClick", {
        /**
         * Gets or sets whether the cluster should zoom in on click
         *
         * @readonly
         * @type {boolean}
         * @memberof ClusterLayerDirective
         */
        get: function () { return this._zoomOnClick; },
        set: function (val) { this._zoomOnClick = val; },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates the dynamic size marker to be used for cluster markers if UseDynamicSizeMarkers is set to true.
     *
     * @protected
     * @static
     * @param {integer} size - The number of markers in the cluster.
     * @param {IMarkerIconInfo} info  - The icon info to be used. This will be hydrated with
     * the actualy dimensions of the created markers and is used by the underlying model/services
     * to correctly offset the marker for correct positioning.
     * @param {number} baseMarkerSize - The base size for dynmic markers.
     * @param {Map<number, string>} ranges - The ranges to use to calculate breakpoints and colors for dynamic markers.
     * The map contains key/value pairs, with the keys being
     * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range.
     * @returns {string} - An string containing the SVG for the marker.
     *
     * @memberof ClusterLayerDirective
     */
    ClusterLayerDirective.CreateDynamicSizeMarker = function (size, info, baseMarkerSize, ranges) {
        var mr = baseMarkerSize;
        var outline = mr * 0.35;
        var total = size;
        var r = Math.log(total) / Math.log(10) * 5 + mr;
        var d = r * 2;
        var fillColor;
        ranges.forEach(function (v, k) {
            if (total <= k && !fillColor) {
                fillColor = v;
            }
        });
        if (!fillColor) {
            fillColor = 'rgba(20, 180, 20, 0.5)';
        }
        ;
        // Create an SVG string of two circles, one on top of the other, with the specified radius and color.
        var svg = ["<svg xmlns='http://www.w3.org/2000/svg' width='" + d + "' height='" + d + "'>",
            "<circle cx='" + r + "' cy='" + r + "' r='" + r + "' fill='" + fillColor + "'/>",
            "<circle cx='" + r + "' cy='" + r + "' r='" + (r - outline) + "' fill='" + fillColor + "'/>",
            "</svg>"];
        info.size = { width: d, height: d };
        info.markerOffsetRatio = { x: 0.5, y: 0.5 };
        info.textOffset = { x: 0, y: r - 8 };
        return svg.join('');
    };
    ///
    /// Public methods
    ///
    /**
     * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
     *
     * @param {{ [propName: string]: SimpleChange }} changes - collection of changes.
     *
     * @memberof ClusterLayerDirective
     */
    ClusterLayerDirective.prototype.ngOnChanges = function (changes) {
        if (!this._addedToManager) {
            return;
        }
        if (changes['ClusterClickAction']) {
            throw (new Error('You cannot change the ClusterClickAction after the layer has been added to the layerservice.'));
        }
        var options = { id: this._id };
        if (changes['ClusteringEnbabled']) {
            options.clusteringEnabled = this._clusteringEnabled;
        }
        if (changes['GridSize']) {
            options.gridSize = this._gridSize;
        }
        if (changes['LayerOffset']) {
            options.layerOffset = this._layerOffset;
        }
        if (changes['SpiderClusterOptions']) {
            options.spiderClusterOptions = this._spiderClusterOptions;
        }
        if (changes['ZIndex']) {
            options.zIndex = this._zIndex;
        }
        if (changes['Visible']) {
            options.visible = this._visible;
        }
        this._layerService.GetNativeLayer(this).then(function (l) {
            l.SetOptions(options);
        });
    };
    return ClusterLayerDirective;
}(map_layer_1.MapLayerDirective));
ClusterLayerDirective.decorators = [
    { type: core_1.Directive, args: [{
                selector: 'x-cluster-layer'
            },] },
];
/** @nocollapse */
ClusterLayerDirective.ctorParameters = function () { return [
    { type: cluster_service_1.ClusterService, },
    { type: core_1.ViewContainerRef, },
]; };
ClusterLayerDirective.propDecorators = {
    'AverageCenter': [{ type: core_1.Input },],
    'ClusterClickAction': [{ type: core_1.Input },],
    'ClusteringEnabled': [{ type: core_1.Input },],
    'ClusterPlacementMode': [{ type: core_1.Input },],
    'CustomMarkerCallback': [{ type: core_1.Input },],
    'DynamicMarkerBaseSize': [{ type: core_1.Input },],
    'DynamicMarkerRanges': [{ type: core_1.Input },],
    'GridSize': [{ type: core_1.Input },],
    'IconInfo': [{ type: core_1.Input },],
    'LayerOffset': [{ type: core_1.Input },],
    'MinimumClusterSize': [{ type: core_1.Input },],
    'SpiderClusterOptions': [{ type: core_1.Input },],
    'Styles': [{ type: core_1.Input },],
    'UseDynamicSizeMarkers': [{ type: core_1.Input },],
    'ZIndex': [{ type: core_1.Input },],
    'ZoomOnClick': [{ type: core_1.Input },],
};
exports.ClusterLayerDirective = ClusterLayerDirective;
//# sourceMappingURL=cluster-layer.js.map