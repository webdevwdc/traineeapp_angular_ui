"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var polygon_service_1 = require("../services/polygon.service");
var infobox_1 = require("./infobox");
var polygonId = 0;
/**
 *
 * MapPolygonDirective renders a polygon inside a {@link MapComponent}.
 *
 * ### Example
 * ```typescript
 * import {Component} from '@angular/core';
 * import {MapComponent, MapPolygonDirective} from '...';
 *
 * @Component({
 *  selector: 'my-map,
 *  styles: [`
 *   .map-container { height: 300px; }
 * `],
 * template: `
 *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
 *      <x-map-polygon [Paths]="path"></x-map-polygon>
 *   </x-map>
 * `
 * })
 * ```
 *
 *
 * @export
 * @class MapPolygonDirective
 * @implements {OnDestroy}
 * @implements {OnChanges}
 * @implements {AfterContentInit}
 */
var MapPolygonDirective = (function () {
    ///
    /// Constructor
    ///
    /**
     * Creates an instance of MapPolygonDirective.
     * @param {PolygonManager} _polygonManager
     *
     * @memberof MapPolygonDirective
     */
    function MapPolygonDirective(_polygonService, _containerRef) {
        this._polygonService = _polygonService;
        this._containerRef = _containerRef;
        ///
        /// Field declarations
        ///
        this._inCustomLayer = false;
        this._addedToService = false;
        this._events = [];
        /**
         * Gets or sets whether this Polygon handles mouse events.
         *
         * @type {boolean}
         * @memberof MapPolygonDirective
         */
        this.Clickable = true;
        /**
         * If set to true, the user can drag this shape over the map.
         *
         * @type {boolean}
         * @memberof MapPolygonDirective
         */
        this.Draggable = false;
        /**
         * If set to true, the user can edit this shape by dragging the control
         * points shown at the vertices and on each segment.
         *
         * @type {boolean}
         * @memberof MapPolygonDirective
         */
        this.Editable = false;
        /**
         * When true, edges of the polygon are interpreted as geodesic and will
         * follow the curvature of the Earth. When false, edges of the polygon are
         * rendered as straight lines in screen space. Note that the shape of a
         * geodesic polygon may appear to change when dragged, as the dimensions
         * are maintained relative to the surface of the earth. Defaults to false.
         *
         * @type {boolean}
         * @memberof MapPolygonDirective
         */
        this.Geodesic = false;
        /**
         * The ordered sequence of coordinates that designates a closed loop.
         * Unlike polylines, a polygon may consist of one or more paths.
         *  As a result, the paths property may specify one or more arrays of
         * LatLng coordinates. Paths are closed automatically; do not repeat the
         * first vertex of the path as the last vertex. Simple polygons may be
         * defined using a single array of LatLngs. More complex polygons may
         * specify an array of arrays. Any simple arrays are converted into Arrays.
         * Inserting or removing LatLngs from the Array will automatically update
         * the polygon on the map.
         *
         * @type {(Array<ILatLong> | Array<Array<ILatLong>>)}
         * @memberof MapPolygonDirective
         */
        this.Paths = [];
        /**
         * Whether to show the title of the polygon as the tooltip on the polygon.
         *
         * @type {boolean}
         * @memberof MapPolygonDirective
         */
        this.ShowTooltip = true;
        ///
        /// Delegate definitions
        ///
        /**
         * This event is fired when the DOM click event is fired on the Polygon.
         *
         *   @type {EventEmitter<MouseEvent>}
         * @memberof MapPolygonDirective
         */
        this.Click = new core_1.EventEmitter();
        /**
         * This event is fired when the DOM dblclick event is fired on the Polygon.
         *
         * @type {EventEmitter<MouseEvent>}
         * @memberof MapPolygonDirective
         */
        this.DblClick = new core_1.EventEmitter();
        /**
         * This event is repeatedly fired while the user drags the polygon.
         *
         * @type {EventEmitter<MouseEvent>}
         * @memberof MapPolygonDirective
         */
        this.Drag = new core_1.EventEmitter();
        /**
         * This event is fired when the user stops dragging the polygon.
         *
         * @type {EventEmitter<MouseEvent>}
         * @memberof MapPolygonDirective
         */
        this.DragEnd = new core_1.EventEmitter();
        /**
         * This event is fired when the user starts dragging the polygon.
         *
         * @type {EventEmitter<MouseEvent>}
         * @memberof MapPolygonDirective
         */
        this.DragStart = new core_1.EventEmitter();
        /**
         * This event is fired when the DOM mousedown event is fired on the Polygon.
         *
         * @type {EventEmitter<MouseEvent>}
         * @memberof MapPolygonDirective
         */
        this.MouseDown = new core_1.EventEmitter();
        /**
         * This event is fired when the DOM mousemove event is fired on the Polygon.
         *
         * @type {EventEmitter<MouseEvent>}
         * @memberof MapPolygonDirective
         */
        this.MouseMove = new core_1.EventEmitter();
        /**
         * This event is fired on Polygon mouseout.
         *
         * @type {EventEmitter<MouseEvent>}
         * @memberof MapPolygonDirective
         */
        this.MouseOut = new core_1.EventEmitter();
        /**
         * This event is fired on Polygon mouseover.
         *
         * @type {EventEmitter<MouseEvent>}
         * @memberof MapPolygonDirective
         */
        this.MouseOver = new core_1.EventEmitter();
        /**
         * This event is fired whe the DOM mouseup event is fired on the Polygon
         *
         * @type {EventEmitter<MouseEvent>}
         * @memberof MapPolygonDirective
         */
        this.MouseUp = new core_1.EventEmitter();
        /**
         * This even is fired when the Polygon is right-clicked on.
         *
         * @type {EventEmitter<MouseEvent>}
         * @memberof MapPolygonDirective
         */
        this.RightClick = new core_1.EventEmitter();
        this._id = polygonId++;
    }
    Object.defineProperty(MapPolygonDirective.prototype, "AddedToService", {
        ///
        /// Property declarations
        ///
        /**
         * Gets whether the polygon has been registered with the service.
         * @readonly
         * @type {boolean}
         * @memberof MapPolygonDirective
         */
        get: function () { return this._addedToService; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MapPolygonDirective.prototype, "Id", {
        /**
         * Get the id of the polygon.
         *
         * @readonly
         * @type {number}
         * @memberof MapPolygonDirective
         */
        get: function () { return this._id; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MapPolygonDirective.prototype, "IdAsString", {
        /**
         * Gets the id of the polygon as a string.
         *
         * @readonly
         * @type {string}
         * @memberof MapPolygonDirective
         */
        get: function () { return this._id.toString(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MapPolygonDirective.prototype, "InCustomLayer", {
        /**
         * Gets whether the polygon is in a custom layer. See {@link MapLayer}.
         *
         * @readonly
         * @type {boolean}
         * @memberof MapPolygonDirective
         */
        get: function () { return this._inCustomLayer; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MapPolygonDirective.prototype, "LayerId", {
        /**
         * gets the id of the Layer the polygon belongs to.
         *
         * @readonly
         * @type {number}
         * @memberof MapPolygonDirective
         */
        get: function () { return this._layerId; },
        enumerable: true,
        configurable: true
    });
    ///
    /// Public methods
    ///
    /**
     * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
     *
     * @return {void}
     *
     * @memberof MapPolygonDirective
     */
    MapPolygonDirective.prototype.ngAfterContentInit = function () {
        if (this._containerRef.element.nativeElement.parentElement) {
            var parentName = this._containerRef.element.nativeElement.parentElement.tagName;
            if (parentName.toLowerCase() === 'x-map-layer') {
                this._inCustomLayer = true;
                this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);
            }
        }
        if (!this._addedToService) {
            this._polygonService.AddPolygon(this);
            this._addedToService = true;
            this.AddEventListeners();
        }
        return;
    };
    /**
     * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
     *
     * @param {{ [propName: string]: SimpleChange }} changes - Changes that have occured.
     * @return {void}
     *
     * @memberof MapPolygonDirective
     */
    MapPolygonDirective.prototype.ngOnChanges = function (changes) {
        if (!this._addedToService) {
            return;
        }
        var o = this.GeneratePolygonChangeSet(changes);
        this._polygonService.SetOptions(this, o);
    };
    /**
     * Called when the poygon is being destroyed. Part of the ng Component life cycle. Release resources.
     *
     *
     * @memberof MapPolygonDirective
     */
    MapPolygonDirective.prototype.ngOnDestroy = function () {
        this._polygonService.DeletePolygon(this);
        this._events.forEach(function (s) { return s.unsubscribe(); });
        ///
        /// remove event subscriptions
        ///
    };
    ///
    /// Private methods
    ///
    /**
     * Wires up the event receivers.
     *
     * @private
     *
     * @memberof MapPolygonDirective
     */
    MapPolygonDirective.prototype.AddEventListeners = function () {
        var _this = this;
        this._events.push(this._polygonService.CreateEventObservable('click', this).subscribe(function (ev) {
            var t = _this;
            if (_this._infoBox != null) {
                _this._infoBox.Open(_this._polygonService.GetCoordinatesFromClick(ev));
            }
        }));
        var handlers = [
            { name: 'click', handler: function (ev) { return _this.Click.emit(ev); } },
            { name: 'dblclick', handler: function (ev) { return _this.DblClick.emit(ev); } },
            { name: 'drag', handler: function (ev) { return _this.Drag.emit(ev); } },
            { name: 'dragend', handler: function (ev) { return _this.DragEnd.emit(ev); } },
            { name: 'dragstart', handler: function (ev) { return _this.DragStart.emit(ev); } },
            { name: 'mousedown', handler: function (ev) { return _this.MouseDown.emit(ev); } },
            { name: 'mousemove', handler: function (ev) { return _this.MouseMove.emit(ev); } },
            { name: 'mouseout', handler: function (ev) { return _this.MouseOut.emit(ev); } },
            { name: 'mouseover', handler: function (ev) { return _this.MouseOver.emit(ev); } },
            { name: 'mouseup', handler: function (ev) { return _this.MouseUp.emit(ev); } },
            { name: 'rightclick', handler: function (ev) { return _this.RightClick.emit(ev); } },
        ];
        handlers.forEach(function (obj) {
            var os = _this._polygonService.CreateEventObservable(obj.name, _this).subscribe(obj.handler);
            _this._events.push(os);
        });
    };
    /**
     * Generates IPolygon option changeset from directive settings.
     *
     * @private
     * @param {SimpleChanges} changes - {@link SimpleChanges} identifying the changes that occured.
     * @returns {IPolygonOptions} - {@link IPolygonOptions} containing the polygon options.
     *
     * @memberof MapPolygonDirective
     */
    MapPolygonDirective.prototype.GeneratePolygonChangeSet = function (changes) {
        var options = { id: this._id };
        if (changes['Clickable']) {
            options.clickable = this.Clickable;
        }
        if (changes['Draggable']) {
            options.draggable = this.Draggable;
        }
        if (changes['Editable']) {
            options.editable = this.Editable;
        }
        if (changes['FillColor']) {
            options.fillColor = this.FillColor;
        }
        if (changes['FillOpacity']) {
            options.fillOpacity = this.FillOpacity;
        }
        if (changes['Geodesic']) {
            options.geodesic = this.Geodesic;
        }
        if (changes['Paths']) {
            options.paths = this.Paths;
        }
        if (changes['LabelMaxZoom']) {
            options.labelMaxZoom = this.LabelMaxZoom;
        }
        if (changes['LabelMinZoom']) {
            options.labelMinZoom = this.LabelMinZoom;
        }
        if (changes['ShowTooltip']) {
            options.showTooltip = this.ShowTooltip;
        }
        if (changes['ShowLabel']) {
            options.showLabel = this.ShowLabel;
        }
        if (changes['Paths']) {
            options.paths = this.Paths;
        }
        if (changes['StrokeColor']) {
            options.strokeColor = this.StrokeColor;
        }
        if (changes['StrokeOpacity']) {
            options.strokeOpacity = this.StrokeOpacity;
        }
        if (changes['StrokeWeight']) {
            options.strokeWeight = this.StrokeWeight;
        }
        if (changes['Title']) {
            options.title = this.Title;
        }
        if (changes['Visible']) {
            options.visible = this.Visible;
        }
        if (changes['zIndex']) {
            options.zIndex = this.zIndex;
        }
        return options;
    };
    return MapPolygonDirective;
}());
MapPolygonDirective.decorators = [
    { type: core_1.Directive, args: [{
                selector: 'x-map-polygon'
            },] },
];
/** @nocollapse */
MapPolygonDirective.ctorParameters = function () { return [
    { type: polygon_service_1.PolygonService, },
    { type: core_1.ViewContainerRef, },
]; };
MapPolygonDirective.propDecorators = {
    '_infoBox': [{ type: core_1.ContentChild, args: [infobox_1.InfoBoxComponent,] },],
    'Clickable': [{ type: core_1.Input },],
    'Draggable': [{ type: core_1.Input },],
    'Editable': [{ type: core_1.Input },],
    'FillColor': [{ type: core_1.Input },],
    'FillOpacity': [{ type: core_1.Input },],
    'Geodesic': [{ type: core_1.Input },],
    'LabelMaxZoom': [{ type: core_1.Input },],
    'LabelMinZoom': [{ type: core_1.Input },],
    'Paths': [{ type: core_1.Input },],
    'ShowLabel': [{ type: core_1.Input },],
    'ShowTooltip': [{ type: core_1.Input },],
    'StrokeColor': [{ type: core_1.Input },],
    'StrokeOpacity': [{ type: core_1.Input },],
    'StrokeWeight': [{ type: core_1.Input },],
    'Title': [{ type: core_1.Input },],
    'Visible': [{ type: core_1.Input },],
    'zIndex': [{ type: core_1.Input },],
    'Click': [{ type: core_1.Output },],
    'DblClick': [{ type: core_1.Output },],
    'Drag': [{ type: core_1.Output },],
    'DragEnd': [{ type: core_1.Output },],
    'DragStart': [{ type: core_1.Output },],
    'MouseDown': [{ type: core_1.Output },],
    'MouseMove': [{ type: core_1.Output },],
    'MouseOut': [{ type: core_1.Output },],
    'MouseOver': [{ type: core_1.Output },],
    'MouseUp': [{ type: core_1.Output },],
    'RightClick': [{ type: core_1.Output },],
};
exports.MapPolygonDirective = MapPolygonDirective;
//# sourceMappingURL=map-polygon.js.map