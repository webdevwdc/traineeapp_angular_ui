"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var google_marker_1 = require("./google-marker");
var marker_1 = require("../marker");
var cluster_placement_mode_1 = require("../cluster-placement-mode");
/**
 * Concrete implementation of a clustering layer for the Bing Map Provider.
 *
 * @export
 * @class GoogleMarkerClusterer
 * @implements {Layer}
 */
var GoogleMarkerClusterer = (function () {
    ///
    /// Constructor
    ///
    /**
     * Creates a new instance of the GoogleMarkerClusterer class.
     *
     * @param _layer GoogleMapTypes.MarkerClusterer. Native Google Maps Marker Clusterer supporting the cluster layer.
     * @param _maps MapService. MapService implementation to leverage for the layer.
     *
     * @memberof GoogleMarkerClusterer
     */
    function GoogleMarkerClusterer(_layer) {
        this._layer = _layer;
        ///
        /// Field declarations
        ///
        this._isClustering = true;
        this._markers = new Array();
        this._pendingMarkers = new Array();
        this._mapclicks = 0;
        this._currentZoom = 0;
        this._visible = true;
    }
    Object.defineProperty(GoogleMarkerClusterer.prototype, "NativePrimitve", {
        ///
        /// Property definitions
        ///
        /**
         * Get the native primitive underneath the abstraction layer.
         *
         * @returns GoogleMapTypes.MarkerClusterer.
         *
         * @memberof GoogleMarkerClusterer
         */
        get: function () {
            return this._layer;
        },
        enumerable: true,
        configurable: true
    });
    ///
    /// Public methods, Layer interface implementation
    ///
    /**
     * Adds an event listener for the layer.
     *
     * @param eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
     * layer supports.
     * @param fn function. Handler to call when the event occurs.
     *
     * @memberof GoogleMarkerClusterer
     */
    GoogleMarkerClusterer.prototype.AddListener = function (eventType, fn) {
        throw (new Error('Events are not supported on Google Cluster Layers. You can still add events to individual markers.'));
    };
    /**
     * Adds an entity to the layer. Use this method with caution as it will
     * trigger a recaluation of the clusters (and associated markers if approprite) for
     * each invocation. If you use this method to add many markers to the cluster, use
     *
     * @param entity Marker|InfoWindow|any. Entity to add to the layer.
     *
     * @memberof GoogleMarkerClusterer
     */
    GoogleMarkerClusterer.prototype.AddEntity = function (entity) {
        if (entity instanceof marker_1.Marker || entity instanceof google_marker_1.GoogleMarker) {
            if (entity.IsFirst) {
                this.StopClustering();
            }
        }
        if (entity.NativePrimitve && entity.Location) {
            if (this._isClustering) {
                this._layer.addMarker(entity.NativePrimitve);
                this._markers.push(entity);
            }
            else {
                this._pendingMarkers.push(entity);
            }
        }
        if (entity instanceof marker_1.Marker || entity instanceof google_marker_1.GoogleMarker) {
            if (entity.IsLast) {
                this.StartClustering();
            }
        }
    };
    /**
     * Deletes the clustering layer.
     *
     * @memberof GoogleMarkerClusterer
     */
    GoogleMarkerClusterer.prototype.Delete = function () {
        this._layer.getMarkers().forEach(function (m) {
            m.setMap(null);
        });
        this._layer.clearMarkers();
        this._markers.splice(0);
        this._pendingMarkers.splice(0);
    };
    /**
     * Returns the abstract marker used to wrap the Google Marker.
     *
     * @returns Marker. The abstract marker object representing the pushpin.
     *
     * @memberof GoogleMarkerClusterer
     */
    GoogleMarkerClusterer.prototype.GetMarkerFromGoogleMarker = function (pin) {
        var i = this._markers.findIndex(function (e) { return e.NativePrimitve === pin; });
        if (i > -1) {
            return this._markers[i];
        }
        return null;
    };
    /**
     * Returns the options governing the behavior of the layer.
     *
     * @returns IClusterOptions. The layer options.
     *
     * @memberof GoogleMarkerClusterer
     */
    GoogleMarkerClusterer.prototype.GetOptions = function () {
        var options = {
            id: 0,
            gridSize: this._layer.getGridSize(),
            clusteringEnabled: this._layer.getGridSize() === 0,
            maxZoom: this._layer.getMaxZoom(),
            minimumClusterSize: this._layer.getMinClusterSize(),
            placementMode: this._layer.isAverageCenter() ? cluster_placement_mode_1.ClusterPlacementMode.MeanValue : cluster_placement_mode_1.ClusterPlacementMode.FirstPin,
            visible: this._visible,
            zoomOnClick: this._layer.isZoomOnClick(),
            styles: this._layer.getStyles()
        };
        return options;
    };
    /**
     * Returns the visibility state of the layer.
     *
     * @returns Boolean. True is the layer is visible, false otherwise.
     *
     * @memberof GoogleMarkerClusterer
     */
    GoogleMarkerClusterer.prototype.GetVisible = function () {
        return this._visible;
    };
    /**
     * Removes an entity from the cluster layer.
     *
     * @param entity Marker|InfoWindow|any Entity to be removed from the layer.
     *
     * @memberof GoogleMarkerClusterer
     */
    GoogleMarkerClusterer.prototype.RemoveEntity = function (entity) {
        if (entity.NativePrimitve && entity.Location) {
            var j = this._markers.findIndex(function (m) { return m === entity; });
            var k = this._pendingMarkers.findIndex(function (m) { return m === entity; });
            if (j > -1) {
                this._markers.splice(j, 1);
            }
            if (k > -1) {
                this._pendingMarkers.splice(k, 1);
            }
            if (this._isClustering) {
                this._layer.removeMarker(entity.NativePrimitve);
            }
        }
    };
    /**
     * Sets the entities for the cluster layer.
     *
     * @param entities Array<Marker>|Array<InfoWindow>|Array<any> containing
     * the entities to add to the cluster. This replaces any existing entities.
     *
     * @memberof GoogleMarkerClusterer
     */
    GoogleMarkerClusterer.prototype.SetEntities = function (entities) {
        var _this = this;
        this._layer.getMarkers().forEach(function (m) {
            m.setMap(null);
        });
        this._layer.clearMarkers();
        this._markers.splice(0);
        this._pendingMarkers.splice(0);
        var p = new Array();
        entities.forEach(function (e) {
            if (e.NativePrimitve && e.Location) {
                _this._markers.push(e);
                p.push(e.NativePrimitve);
            }
        });
        this._layer.addMarkers(p);
    };
    /**
     * Sets the options for the cluster layer.
     *
     * @param options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
     * are merged with the default/existing options.
     *
     * @memberof GoogleMarkerClusterer
     */
    GoogleMarkerClusterer.prototype.SetOptions = function (options) {
        if (options.placementMode != null) {
            throw (new Error('GoogleMarkerClusterer: PlacementMode option cannot be set after initial creation.'));
        }
        ;
        if (options.zoomOnClick != null) {
            throw (new Error('GoogleMarkerClusterer: ZoomOnClick option cannot be set after initial creation.'));
        }
        if (options.callback != null) { }
        if (options.clusteringEnabled != null && !options.clusteringEnabled) {
            this._layer.setGridSize(0);
        }
        if (options.gridSize != null && (options.clusteringEnabled == null || options.clusteringEnabled)) {
            this._layer.setGridSize(options.gridSize);
        }
        if (options.maxZoom != null) {
            this._layer.setMaxZoom(options.maxZoom);
        }
        if (options.minimumClusterSize != null) {
            this._layer.setMinClusterSize(options.minimumClusterSize);
        }
        if (options.styles != null) {
            this._layer.setStyles(options.styles);
        }
        if (options.visible != null) {
            this.SetVisible(options.visible);
        }
    };
    /**
     * Toggles the cluster layer visibility.
     *
     * @param visible Boolean true to make the layer visible, false to hide the layer.
     *
     * @memberof GoogleMarkerClusterer
     */
    GoogleMarkerClusterer.prototype.SetVisible = function (visible) {
        var map = visible ? this._layer.getMap() : null;
        this._layer.getMarkers().forEach(function (m) {
            m.setMap(map);
        });
        this._visible = visible;
    };
    /**
     * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
     * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
     * complete to recalculate the clusters.
     *
     * @returns {void}
     *
     * @memberof GoogleMarkerClusterer
     */
    GoogleMarkerClusterer.prototype.StartClustering = function () {
        if (this._isClustering) {
            return;
        }
        var p = new Array();
        this._markers.forEach(function (e) {
            if (e.NativePrimitve && e.Location) {
                p.push(e.NativePrimitve);
            }
        });
        this._pendingMarkers.forEach(function (e) {
            if (e.NativePrimitve && e.Location && p.findIndex(function (x) { return x === e.NativePrimitve; }) === -1) {
                p.push(e.NativePrimitve);
            }
        });
        this._layer.addMarkers(p);
        this._markers = this._markers.concat(this._pendingMarkers.splice(0));
        this._isClustering = true;
    };
    ;
    /**
     * Stop to actually cluster the entities in a cluster layer.
     * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
     * complete to recalculate the clusters.
     *
     * @returns
     *
     * @memberof GoogleMarkerClusterer
     */
    GoogleMarkerClusterer.prototype.StopClustering = function () {
        if (!this._isClustering) {
            return;
        }
        this._isClustering = false;
    };
    ;
    return GoogleMarkerClusterer;
}());
exports.GoogleMarkerClusterer = GoogleMarkerClusterer;
//# sourceMappingURL=google-marker-clusterer.js.map