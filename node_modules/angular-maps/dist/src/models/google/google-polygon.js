"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var google_conversions_1 = require("../../services/google/google-conversions");
var polygon_1 = require("../polygon");
var google_label_1 = require("./google-label");
/**
 * Concrete implementation for a polygon model for Google Maps.
 *
 * @export
 * @implements Polygon
 * @extends Polygon
 * @class GooglePolygon
 */
var GooglePolygon = (function (_super) {
    __extends(GooglePolygon, _super);
    ///
    /// constructor
    ///
    /**
     * Creates an instance of GooglePolygon.
     * @param {GoogleMapTypes.Polygon} _polygon - The {@link GoogleMapTypes.Polygon} underlying the model.
     *
     * @memberof GooglePolygon
     */
    function GooglePolygon(_polygon) {
        var _this = _super.call(this) || this;
        _this._polygon = _polygon;
        _this._title = '';
        _this._showLabel = false;
        _this._showTooltip = false;
        _this._maxZoom = -1;
        _this._minZoom = -1;
        _this._label = null;
        _this._tooltip = null;
        _this._tooltipVisible = false;
        _this._hasToolTipReceiver = false;
        _this._mouseOverListener = null;
        _this._mouseOutListener = null;
        _this._mouseMoveListener = null;
        return _this;
    }
    Object.defineProperty(GooglePolygon.prototype, "LabelMaxZoom", {
        ///
        /// Property declarations
        ///
        /**
         * Gets or sets the maximum zoom at which the label is displayed. Ignored or ShowLabel is false.
         *
         * @type {number}
         * @memberof GooglePolygon
         * @property
         * @public
         */
        get: function () { return this._maxZoom; },
        set: function (val) {
            this._maxZoom = val;
            this.ManageLabel();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GooglePolygon.prototype, "LabelMinZoom", {
        /**
         * Gets or sets the minimum zoom at which the label is displayed. Ignored or ShowLabel is false.
         *
         * @type {number}
         * @memberof GooglePolygon
         * @property
         * @public
         */
        get: function () { return this._minZoom; },
        set: function (val) {
            this._minZoom = val;
            this.ManageLabel();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GooglePolygon.prototype, "Centroid", {
        /**
         * Gets the polygon's centroid.
         * @readonly
         * @private
         * @type {GoogleMapTypes.LatLngLiteral}
         * @memberof GooglePolygon
         */
        get: function () {
            return google_conversions_1.GoogleConversions.TranslateLocation(this.GetPolygonCentroid());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GooglePolygon.prototype, "NativePrimitve", {
        /**
         * Gets the native primitve implementing the polygon, in this case {@link GoogleMapTypes.Polygon}
         *
         * @readonly
         * @type {GoogleMapTypes.Polygon}
         * @memberof GooglePolygon
         */
        get: function () { return this._polygon; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GooglePolygon.prototype, "ShowLabel", {
        /**
         * Gets or sets whether to show the label
         *
         * @abstract
         * @type {boolean}
         * @memberof GooglePolygon
         * @property
         * @public
         */
        get: function () { return this._showLabel; },
        set: function (val) {
            this._showLabel = val;
            this.ManageLabel();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GooglePolygon.prototype, "ShowTooltip", {
        /**
         * Gets or sets whether to show the tooltip
         *
         * @abstract
         * @type {boolean}
         * @memberof GooglePolygon
         * @property
         * @public
         */
        get: function () { return this._showTooltip; },
        set: function (val) {
            this._showTooltip = val;
            this.ManageTooltip();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GooglePolygon.prototype, "Title", {
        /**
         * Gets or sets the title off the polygon
         *
         * @abstract
         * @type {string}
         * @memberof GooglePolygon
         * @property
         * @public
         */
        get: function () { return this._title; },
        set: function (val) {
            this._title = val;
            this.ManageLabel();
            this.ManageTooltip();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds a delegate for an event.
     *
     * @param {string} eventType - String containing the event name.
     * @param fn - Delegate function to execute when the event occurs.

     * @memberof GooglePolygon
     */
    GooglePolygon.prototype.AddListener = function (eventType, fn) {
        this._polygon.addListener(eventType, fn);
    };
    /**
     * Deleted the polygon.
     *
     * @memberof GooglePolygon
     */
    GooglePolygon.prototype.Delete = function () {
        this._polygon.setMap(null);
        if (this._label) {
            this._label.Delete();
        }
        if (this._tooltip) {
            this._tooltip.Delete();
        }
    };
    /**
     * Gets whether the polygon is draggable.
     *
     * @returns {boolean} - True if the polygon is dragable, false otherwise.
     *
     * @memberof GooglePolygon
     */
    GooglePolygon.prototype.GetDraggable = function () {
        return this._polygon.getDraggable();
    };
    /**
     * Gets whether the polygon path can be edited.
     *
     * @returns {boolean} - True if the path can be edited, false otherwise.
     *
     * @memberof GooglePolygon
     */
    GooglePolygon.prototype.GetEditable = function () {
        return this._polygon.getEditable();
    };
    /**
     * Gets the polygon path.
     *
     * @returns {Array<ILatLong>} - Array of {@link ILatLong} objects describing the polygon path.
     *
     * @memberof GooglePolygon
     */
    GooglePolygon.prototype.GetPath = function () {
        var p = this._polygon.getPath();
        var path = new Array();
        p.forEach(function (x) { return path.push({ latitude: x.lat(), longitude: x.lng() }); });
        return path;
    };
    /**
     * Gets the polygon paths.
     *
     * @returns {Array<Array<ILatLong>>} - Array of Array of {@link ILatLong} objects describing multiple polygon paths.
     *
     * @memberof GooglePolygon
     */
    GooglePolygon.prototype.GetPaths = function () {
        var p = this._polygon.getPaths();
        var paths = new Array();
        p.forEach(function (x) {
            var path = new Array();
            x.forEach(function (y) { return path.push({ latitude: y.lat(), longitude: y.lng() }); });
            paths.push(path);
        });
        return paths;
    };
    /**
     * Gets whether the polygon is visible.
     *
     * @returns {boolean} - True if the polygon is visible, false otherwise.
     *
     * @memberof GooglePolygon
     */
    GooglePolygon.prototype.GetVisible = function () {
        return this._polygon.getVisible();
    };
    /**
     * Sets whether the polygon is dragable.
     *
     * @param {boolean} draggable - True to make the polygon dragable, false otherwise.
     *
     * @memberof GooglePolygon
     */
    GooglePolygon.prototype.SetDraggable = function (draggable) {
        this._polygon.setDraggable(draggable);
    };
    /**
     * Sets wether the polygon path is editable.
     *
     * @param {boolean} editable - True to make polygon path editable, false otherwise.
     *
     * @memberof GooglePolygon
     */
    GooglePolygon.prototype.SetEditable = function (editable) {
        this._polygon.setEditable(editable);
    };
    /**
     * Sets the polygon options
     *
     * @param {IPolygonOptions} options - {@link ILatLong} object containing the options. The options are merged with hte ones
     * already on the underlying model.
     *
     * @memberof GooglePolygon
     */
    GooglePolygon.prototype.SetOptions = function (options) {
        var o = google_conversions_1.GoogleConversions.TranslatePolygonOptions(options);
        this._polygon.setOptions(o);
        if (options.visible != null && this._showLabel && this._label) {
            this._label.Set('hidden', !options.visible);
        }
    };
    /**
     * Sets the polygon path.
     *
     * @param {Array<ILatLong>} path - An Array of {@link ILatLong} (or array of arrays) describing the polygons path.
     *
     * @memberof GooglePolygon
     */
    GooglePolygon.prototype.SetPath = function (path) {
        var p = new Array();
        path.forEach(function (x) { return p.push(new google.maps.LatLng(x.latitude, x.longitude)); });
        this._polygon.setPath(p);
    };
    /**
     * Set the polygon path or paths.
     *
     * @param {(Array<Array<ILatLong>> | Array<ILatLong>)} paths An Array of {@link ILatLong}
     * (or array of arrays) describing the polygons path(s).
     *
     * @memberof GooglePolygon
     */
    GooglePolygon.prototype.SetPaths = function (paths) {
        if (paths == null) {
            return;
        }
        if (!Array.isArray(paths)) {
            return;
        }
        if (paths.length === 0) {
            this._polygon.setPaths(new Array());
            return;
        }
        if (Array.isArray(paths[0])) {
            // parameter is an array or arrays
            var p_1 = new Array();
            paths.forEach(function (path) {
                var _p = new Array();
                path.forEach(function (x) { return _p.push(new google.maps.LatLng(x.latitude, x.longitude)); });
                p_1.push(_p);
            });
            this._polygon.setPaths(p_1);
        }
        else {
            // parameter is a simple array....
            this.SetPath(paths);
        }
    };
    /**
     * Sets whether the polygon is visible.
     *
     * @param {boolean} visible - True to set the polygon visible, false otherwise.
     *
     * @memberof GooglePolygon
     */
    GooglePolygon.prototype.SetVisible = function (visible) {
        this._polygon.setVisible(visible);
        if (this._showLabel && this._label) {
            this._label.Set('hidden', !visible);
        }
    };
    ///
    /// Private methods
    ///
    /**
     * Configures the label for the polygon
     * @memberof GooglePolygon
     * @private
     */
    GooglePolygon.prototype.ManageLabel = function () {
        if (this._showLabel && this._title != null && this._title !== '') {
            var o = {
                text: this._title,
                position: this.Centroid
            };
            if (this._minZoom !== -1) {
                o.minZoom = this._minZoom;
            }
            if (this._maxZoom !== -1) {
                o.maxZoom = this._maxZoom;
            }
            if (this._label == null) {
                o.map = this.NativePrimitve.getMap();
                o.zIndex = this.NativePrimitve.zIndex ? this.NativePrimitve.zIndex + 1 : 100;
                this._label = new google_label_1.GoogleMapLabel(o);
            }
            else {
                this._label.SetValues(o);
            }
            this._label.Set('hidden', !this.GetVisible());
        }
        else {
            if (this._label) {
                this._label.SetMap(null);
                this._label = null;
            }
        }
    };
    /**
     * Configures the tooltip for the polygon
     * @memberof GooglePolygon
     * @private
     */
    GooglePolygon.prototype.ManageTooltip = function () {
        var _this = this;
        if (this._showTooltip && this._title != null && this._title !== '') {
            var o = {
                text: this._title,
                align: 'left',
                offset: new google.maps.Point(0, 25),
                backgroundColor: 'bisque',
                hidden: true
            };
            if (this._tooltip == null) {
                o.map = this.NativePrimitve.getMap();
                o.zIndex = 100000;
                this._tooltip = new google_label_1.GoogleMapLabel(o);
            }
            else {
                this._tooltip.SetValues(o);
            }
            if (!this._hasToolTipReceiver) {
                this._mouseOverListener = this.NativePrimitve.addListener('mouseover', function (e) {
                    _this._tooltip.Set('position', e.latLng);
                    if (!_this._tooltipVisible) {
                        _this._tooltip.Set('hidden', false);
                        _this._tooltipVisible = true;
                    }
                });
                this._mouseMoveListener = this.NativePrimitve.addListener('mousemove', function (e) {
                    if (_this._tooltipVisible) {
                        _this._tooltip.Set('position', e.latLng);
                    }
                });
                this._mouseOutListener = this.NativePrimitve.addListener('mouseout', function (e) {
                    if (_this._tooltipVisible) {
                        _this._tooltip.Set('hidden', true);
                        _this._tooltipVisible = false;
                    }
                });
                this._hasToolTipReceiver = true;
            }
        }
        if ((!this._showTooltip || this._title === '' || this._title == null)) {
            if (this._hasToolTipReceiver) {
                if (this._mouseOutListener) {
                    google.maps.event.removeListener(this._mouseOutListener);
                }
                if (this._mouseOverListener) {
                    google.maps.event.removeListener(this._mouseOverListener);
                }
                if (this._mouseMoveListener) {
                    google.maps.event.removeListener(this._mouseMoveListener);
                }
                this._hasToolTipReceiver = false;
            }
            if (this._tooltip) {
                this._tooltip.SetMap(null);
                this._tooltip = null;
            }
        }
    };
    return GooglePolygon;
}(polygon_1.Polygon));
exports.GooglePolygon = GooglePolygon;
//# sourceMappingURL=google-polygon.js.map