"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Abstract base implementing a label to be placed on the map.
 *
 * @export
 * @abstract
 * @class MapLabel
 */
var MapLabel = (function () {
    ///
    /// Constructor
    ///
    /**
     * Creates a new MapLabel
     * @constructor
     * @param {{ [key: string]: any }} opt_options Optional properties to set.
     * @constructor
     * @public
     */
    function MapLabel(options) {
        this.Set('fontFamily', 'sans-serif');
        this.Set('fontSize', 12);
        this.Set('fontColor', '#000000');
        this.Set('strokeWeight', 4);
        this.Set('strokeColor', '#ffffff');
        this.Set('align', 'center');
        this.SetValues(options);
    }
    ///
    /// Public methods
    ///
    /**
     * Deletes the label from the map. This method does not atually delete the label itself, so
     * it can be readded to map later.
     * @memberof MapLabel
     * @method
     * @public
     */
    MapLabel.prototype.Delete = function () {
        this.SetMap(null);
    };
    /**
     * Delegate called when underlying properties change.
     *
     * @param {string | Array<string>} prop - The property or properties that have changed.
     * @returns {void}
     * @memberof MapLabel
     * @method
     * @public
     */
    MapLabel.prototype.Changed = function (prop) {
        var shouldRunDrawCanvas = false;
        var shouldRunDraw = false;
        if (!Array.isArray(prop)) {
            prop = [prop];
        }
        prop.forEach(function (p) {
            switch (p) {
                case 'fontFamily':
                case 'fontSize':
                case 'fontColor':
                case 'strokeWeight':
                case 'strokeColor':
                case 'align':
                case 'text':
                    shouldRunDrawCanvas = true;
                    break;
                case 'maxZoom':
                case 'minZoom':
                case 'offset':
                case 'hidden':
                case 'position':
                    shouldRunDraw = true;
                    break;
            }
        });
        if (shouldRunDrawCanvas) {
            this.DrawCanvas();
        }
        if (shouldRunDraw) {
            this.Draw();
        }
    };
    ///
    /// Protected methods
    ///
    /**
     * Get the visibility of the label. Visibility depends on Zoom settings.
     * @return {string} blank string if visible, 'hidden' if invisible.
     * @protected
     */
    MapLabel.prototype.GetVisible = function () {
        var minZoom = this.Get('minZoom');
        var maxZoom = this.Get('maxZoom');
        var hidden = this.Get('hidden');
        if (hidden) {
            return 'hidden';
        }
        if (minZoom === undefined && maxZoom === undefined) {
            return '';
        }
        if (!this.GetMap()) {
            return '';
        }
        var mapZoom = this.GetMap().getZoom();
        if (mapZoom < minZoom || mapZoom > maxZoom) {
            return 'hidden';
        }
        return '';
    };
    ;
    /**
     * Draws the label to the canvas 2d context.
     * @memberof MapLabel
     * @method
     * @protected
     */
    MapLabel.prototype.DrawCanvas = function () {
        if (!this._canvas) {
            return;
        }
        var style = this._canvas.style;
        style.zIndex = this.Get('zIndex');
        var ctx = this._canvas.getContext('2d');
        ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
        ctx.strokeStyle = this.Get('strokeColor');
        ctx.font = this.Get('fontSize') + 'px ' + this.Get('fontFamily');
        var backgroundColor = this.Get('backgroundColor');
        var strokeWeight = Number(this.Get('strokeWeight'));
        var text = this.Get('text');
        var textMeasure = ctx.measureText(text);
        var textWidth = textMeasure.width + strokeWeight;
        if (text && strokeWeight && strokeWeight > 0) {
            ctx.lineWidth = strokeWeight;
            ctx.strokeText(text, strokeWeight, strokeWeight);
        }
        if (backgroundColor && backgroundColor !== '') {
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, textWidth + 5, (parseInt(ctx.font, 10) * 2) - 2);
        }
        ctx.fillStyle = this.Get('fontColor');
        ctx.fillText(text, strokeWeight, strokeWeight);
        style.marginLeft = this.GetMarginLeft(textWidth) + 'px';
        style.marginTop = '-0.4em';
        // Bring actual text top in line with desired latitude.
        // Cheaper than calculating height of text.
    };
    /**
     * Gets the appropriate margin-left for the canvas.
     * @param {number} textWidth  - The width of the text, in pixels.
     * @return {number} - The margin-left, in pixels.
     * @protected
     * @method
     * @memberof MapLabel
     */
    MapLabel.prototype.GetMarginLeft = function (textWidth) {
        switch (this.Get('align')) {
            case 'left': return 0;
            case 'right': return -textWidth;
        }
        return textWidth / -2;
    };
    ;
    /**
     * Called when the label is removed from the map.
     * @method
     * @protected
     * @memberof MapLabel
     */
    MapLabel.prototype.OnRemove = function () {
        if (this._canvas && this._canvas.parentNode) {
            this._canvas.parentNode.removeChild(this._canvas);
        }
    };
    ;
    return MapLabel;
}());
exports.MapLabel = MapLabel;
//# sourceMappingURL=map-label.js.map