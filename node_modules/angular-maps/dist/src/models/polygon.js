"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Abstract class defining the contract for a polygon in the architecture specific implementation.
 *
 * @export
 * @abstract
 * @class Polygon
 */
var Polygon = (function () {
    function Polygon() {
    }
    ///
    /// Protected methods
    ///
    /**
     * Gets the center of the polygons' bounding box.
     *
     * @returns {ILatLong} - {@link ILatLong} object containing the center of the bounding box.
     * @memberof Polygon
     * @method
     * @protected
     */
    Polygon.prototype.GetBoundingCenter = function () {
        var c = { latitude: 0, longitude: 0 };
        var x1 = 90, x2 = -90, y1 = 180, y2 = -180;
        var path = this.GetPath();
        if (path) {
            path.forEach(function (p) {
                if (p.latitude < x1) {
                    x1 = p.latitude;
                }
                if (p.latitude > x2) {
                    x2 = p.latitude;
                }
                if (p.longitude < y1) {
                    y1 = p.longitude;
                }
                if (p.longitude > y2) {
                    y2 = p.longitude;
                }
            });
            c.latitude = x1 + (x2 - x1) / 2;
            c.longitude = y1 + (y2 - y1) / 2;
        }
        return c;
    };
    /**
     * Get the centroid of the polygon based on the polygon path.
     *
     * @return {ILatLong} - The centroid coordinates of the polygon.
     * @memberof Polygon
     * @method
     * @protected
     */
    Polygon.prototype.GetPolygonCentroid = function () {
        var c = { latitude: 0, longitude: 0 };
        var path = this.GetPath();
        var off = path[0];
        var twicearea = 0;
        var x = 0;
        var y = 0;
        var p1, p2;
        var f;
        for (var i = 0, j = path.length - 1; i < path.length; j = i++) {
            p1 = path[i];
            p2 = path[j];
            f = (p1.latitude - off.latitude) * (p2.longitude - off.longitude) -
                (p2.latitude - off.latitude) * (p1.longitude - off.longitude);
            twicearea += f;
            x += (p1.latitude + p2.latitude - 2 * off.latitude) * f;
            y += (p1.longitude + p2.longitude - 2 * off.longitude) * f;
        }
        f = twicearea * 3;
        c.latitude = x / f + off.latitude;
        c.longitude = y / f + off.longitude;
        return c;
    };
    return Polygon;
}());
exports.Polygon = Polygon;
//# sourceMappingURL=polygon.js.map