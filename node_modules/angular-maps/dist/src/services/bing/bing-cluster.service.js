"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var marker_1 = require("./../../models/marker");
var marker_type_id_1 = require("./../../models/marker-type-id");
var cluster_click_action_1 = require("./../../models/cluster-click-action");
var map_service_1 = require("./../map.service");
var bing_layer_base_1 = require("./bing-layer-base");
/**
 * Implements the {@link ClusterService} contract for a  Bing Maps V8 specific implementation.
 *
 * @export
 * @class BingClusterService
 * @extends {BingLayerBase}
 * @implements {ClusterService}
 */
var BingClusterService = (function (_super) {
    __extends(BingClusterService, _super);
    ///
    /// Constructor
    ///
    /**
     * Creates an instance of BingClusterService.
     * @param {MapService} _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.
     * @param {NgZone} _zone - NgZone instance to provide zone aware promises.
     *
     * @memberof BingClusterService
     */
    function BingClusterService(_mapService, _zone) {
        var _this = _super.call(this, _mapService) || this;
        _this._zone = _zone;
        ///
        /// Field declarations
        ///
        _this._layers = new Map();
        return _this;
    }
    ///
    /// Public methods
    ///
    /**
     * Adds a layer to the map.
     *
     * @abstract
     * @param {ClusterLayerDirective} layer - ClusterLayerDirective component object.
     * Generally, MapLayer will be injected with an instance of the
     * LayerService and then self register on initialization.
     *
     * @memberof BingClusterService
     */
    BingClusterService.prototype.AddLayer = function (layer) {
        var _this = this;
        var options = {
            id: layer.Id,
            visible: layer.Visible,
            clusteringEnabled: layer.ClusteringEnabled,
            placementMode: layer.ClusterPlacementMode
        };
        if (layer.GridSize) {
            options.gridSize = layer.GridSize;
        }
        if (layer.LayerOffset) {
            options.layerOffset = layer.LayerOffset;
        }
        if (layer.ZIndex) {
            options.zIndex = layer.ZIndex;
        }
        if (layer.IconInfo) {
            options.clusteredPinCallback = function (pin) { _this.CreateClusterPushPin(pin, layer); };
        }
        if (layer.CustomMarkerCallback) {
            options.clusteredPinCallback = function (pin) { _this.CreateCustomClusterPushPin(pin, layer); };
        }
        if (layer.SpiderClusterOptions) {
            options.spiderClusterOptions = layer.SpiderClusterOptions;
        }
        var layerPromise = this._mapService.CreateClusterLayer(options);
        this._mapService.MapPromise.then(function (m) {
            Microsoft.Maps.Events.addHandler(m, 'viewchangeend', function (e) {
                if (layer.ClusteringEnabled && m.getZoom() === 19) {
                    layerPromise.then(function (l) {
                        l.SetOptions({ id: layer.Id, clusteringEnabled: false });
                    });
                }
                if (layer.ClusteringEnabled && m.getZoom() < 19) {
                    layerPromise.then(function (l) {
                        if (!l.GetOptions().clusteringEnabled) {
                            l.SetOptions({ id: layer.Id, clusteringEnabled: true });
                        }
                    });
                }
            });
        });
        this._layers.set(layer, layerPromise);
    };
    /**
     * Adds a polygon to the layer.
     *
     * @abstract
     * @param {number} layer - The id of the layer to which to add the polygon.
     * @param {IPolygonOptions} options - Polygon options defining the polygon.
     * @returns {Promise<Polygon>} - A promise that when fullfilled contains the an instance of the Polygon model.
     *
     * @memberof BingClusterService
     */
    BingClusterService.prototype.CreatePolygon = function (layer, options) {
        throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));
    };
    /**
     * Adds a polyline to the layer.
     *
     * @abstract
     * @param {number} layer - The id of the layer to which to add the line.
     * @param {IPolylineOptions} options - Polyline options defining the line.
     * @returns {Promise<Polyline|ArraY<Polyline>>} - A promise that when fullfilled contains the an instance of the Polyline (or an array
     * of polygons for complex paths) model.
     *
     * @memberof BingClusterService
     */
    BingClusterService.prototype.CreatePolyline = function (layer, options) {
        throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));
    };
    /**
     * Returns the Layer model represented by this layer.
     *
     * @abstract
     * @param {ClusterLayerDirective} layer - ClusterLayerDirective component object for which to retrieve the layer model.
     * @returns {Promise<Layer>} - A promise that when resolved contains the Layer model.
     *
     * @memberof BingClusterService
     */
    BingClusterService.prototype.GetNativeLayer = function (layer) {
        return this._layers.get(layer);
    };
    /**
     * Deletes the layer
     *
     * @abstract
     * @param {ClusterLayerDirective} layer - ClusterLayerDirective component object for which to retrieve the layer.
     * @returns {Promise<void>} - A promise that is fullfilled when the layer has been removed.
     *
     * @memberof BingClusterService
     */
    BingClusterService.prototype.DeleteLayer = function (layer) {
        var _this = this;
        var l = this._layers.get(layer);
        if (l == null) {
            return Promise.resolve();
        }
        return l.then(function (l1) {
            return _this._zone.run(function () {
                l1.Delete();
                _this._layers.delete(layer);
            });
        });
    };
    /**
     * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
     * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
     * complete to recalculate the clusters.
     *
     * @param {ClusterLayerDirective} layer - ClusterLayerDirective component object for which to retrieve the layer.
     * @returns {Promise<void>}
     *
     * @memberof BingClusterService
     */
    BingClusterService.prototype.StartClustering = function (layer) {
        var _this = this;
        var l = this._layers.get(layer);
        if (l == null) {
            return Promise.resolve();
        }
        return l.then(function (l1) {
            return _this._zone.run(function () {
                l1.StartClustering();
            });
        });
    };
    /**
     * Stop to actually cluster the entities in a cluster layer.
     * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
     * complete to recalculate the clusters.
     *
     * @param {ClusterLayerDirective} layer - ClusterLayerDirective component object for which to retrieve the layer.
     * @returns {Promise<void>}
     *
     * @memberof BingClusterService
     */
    BingClusterService.prototype.StopClustering = function (layer) {
        var _this = this;
        var l = this._layers.get(layer);
        if (l == null) {
            return Promise.resolve();
        }
        return l.then(function (l1) {
            return _this._zone.run(function () {
                l1.StopClustering();
            });
        });
    };
    ///
    /// Private methods
    ///
    /**
     * Creates the default cluster pushpin as a callback from BingMaps when clustering occurs. The {@link ClusterLayerDirective} model
     * can provide an IconInfo property that would govern the apparenace of the pin. This method will assign the same pin to all
     * clusters in the layer.
     *
     * @private
     * @param {Microsoft.Maps.ClusterPushpin} cluster - The cluster for which to create the pushpin.
     * @param {ClusterLayerDirective} layer - The {@link ClusterLayerDirective} component representing the layer.
     *
     * @memberof BingClusterService
     */
    BingClusterService.prototype.CreateClusterPushPin = function (cluster, layer) {
        var _this = this;
        this._layers.get(layer).then(function (l) {
            if (layer.IconInfo) {
                var o_1 = {};
                var payload_1 = function (s, i) {
                    o_1.icon = s;
                    o_1.anchor = new Microsoft.Maps.Point((i.size && i.markerOffsetRatio) ? (i.size.width * i.markerOffsetRatio.x) : 0, (i.size && i.markerOffsetRatio) ? (i.size.height * i.markerOffsetRatio.y) : 0);
                    cluster.setOptions(o_1);
                };
                var s = marker_1.Marker.CreateMarker(layer.IconInfo);
                if (typeof (s) === 'string') {
                    payload_1(s, layer.IconInfo);
                }
                else {
                    s.then(function (x) {
                        payload_1(x.icon, x.iconInfo);
                    });
                }
            }
            if (layer.ClusterClickAction === cluster_click_action_1.ClusterClickAction.ZoomIntoCluster) {
                Microsoft.Maps.Events.addHandler(cluster, 'click', function (e) { return _this.ZoomIntoCluster(e); });
            }
            if (layer.ClusterClickAction === cluster_click_action_1.ClusterClickAction.Spider) {
                Microsoft.Maps.Events.addHandler(cluster, 'dblclick', function (e) { return _this.ZoomIntoCluster(e); });
                l.InitializeSpiderClusterSupport();
            }
        });
    };
    /**
     * Provides a hook for consumers to provide a custom function to create cluster bins for a cluster. This is particuarily useful
     * in situation where the pin should differ to represent information about the pins in the cluster.
     *
     * @private
     * @param {Microsoft.Maps.ClusterPushpin} cluster - The cluster for which to create the pushpin.
     * @param {ClusterLayerDirective} layer - The {@link ClusterLayerDirective} component
     * representing the layer. Set the {@link ClusterLayerDirective.CustomMarkerCallback}
     * property to define the callback generating the pin.
     *
     * @memberof BingClusterService
     */
    BingClusterService.prototype.CreateCustomClusterPushPin = function (cluster, layer) {
        var _this = this;
        this._layers.get(layer).then(function (l) {
            // assemble markers for callback
            var m = new Array();
            cluster.containedPushpins.forEach(function (p) {
                var marker = l.GetMarkerFromBingMarker(p);
                if (marker) {
                    m.push(marker);
                }
            });
            var iconInfo = { markerType: marker_type_id_1.MarkerTypeId.None };
            var o = {};
            o.icon = layer.CustomMarkerCallback(m, iconInfo);
            if (o.icon !== '') {
                o.anchor = new Microsoft.Maps.Point((iconInfo.size && iconInfo.markerOffsetRatio) ? (iconInfo.size.width * iconInfo.markerOffsetRatio.x) : 0, (iconInfo.size && iconInfo.markerOffsetRatio) ? (iconInfo.size.height * iconInfo.markerOffsetRatio.y) : 0);
                if (iconInfo.textOffset) {
                    o.textOffset = new Microsoft.Maps.Point(iconInfo.textOffset.x, iconInfo.textOffset.y);
                }
                cluster.setOptions(o);
            }
            if (layer.ClusterClickAction === cluster_click_action_1.ClusterClickAction.ZoomIntoCluster) {
                Microsoft.Maps.Events.addHandler(cluster, 'click', function (e) { return _this.ZoomIntoCluster(e); });
            }
            if (layer.ClusterClickAction === cluster_click_action_1.ClusterClickAction.Spider) {
                Microsoft.Maps.Events.addHandler(cluster, 'dblclick', function (e) { return _this.ZoomIntoCluster(e); });
                l.InitializeSpiderClusterSupport();
            }
        });
    };
    /**
     * Zooms into the cluster on click so that the members of the cluster comfortable fit into the zommed area.
     *
     * @private
     * @param {Microsoft.Maps.IMouseEventArgs} e - Mouse Event.
     *
     * @memberof BingClusterService
     */
    BingClusterService.prototype.ZoomIntoCluster = function (e) {
        var pin = e.target;
        if (pin && pin.containedPushpins) {
            var bounds_1;
            var locs_1 = new Array();
            pin.containedPushpins.forEach(function (p) { return locs_1.push(p.getLocation()); });
            bounds_1 = Microsoft.Maps.LocationRect.fromLocations(locs_1);
            // Zoom into the bounding box of the cluster.
            // Add a padding to compensate for the pixel area of the pushpins.
            this._mapService.MapPromise.then(function (m) {
                m.setView({ bounds: bounds_1, padding: 75 });
            });
        }
    };
    return BingClusterService;
}(bing_layer_base_1.BingLayerBase));
BingClusterService.decorators = [
    { type: core_1.Injectable },
];
/** @nocollapse */
BingClusterService.ctorParameters = function () { return [
    { type: map_service_1.MapService, },
    { type: core_1.NgZone, },
]; };
exports.BingClusterService = BingClusterService;
//# sourceMappingURL=bing-cluster.service.js.map