"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var map_type_id_1 = require("./../../models/map-type-id");
var marker_1 = require("./../../models/marker");
var cluster_placement_mode_1 = require("./../../models/cluster-placement-mode");
/**
 * This class contains helperfunctions to map various interfaces used to represent options and structures into the
 * corresponding Bing Maps V8 specific implementations.
 *
 * @export
 * @class BingConversions
 */
var BingConversions = (function () {
    function BingConversions() {
    }
    ///
    /// Public methods
    ///
    /**
     * Maps an IInfoWindowAction to a Microsoft.Maps.IInfoboxActions
     *
     * @static
     * @param {IInfoWindowAction} action - Object to be mapped.
     * @returns {Microsoft.Maps.IInfoboxActions} - Navtive mapped object.
     *
     * @memberof BingConversions
     */
    BingConversions.TranslateAction = function (action) {
        var a = {
            eventHandler: action.eventHandler,
            label: action.label
        };
        return a;
    };
    /**
     * Maps an Array of IInfoWindowAction to an Array of Microsoft.Maps.IInfoboxActions
     *
     * @static
     * @param {Array<IInfoWindowAction>} actions - Array of objects to be mapped.
     * @returns {Array<Microsoft.Maps.IInfoboxActions>} - Array of mapped objects.
     *
     * @memberof BingConversions
     */
    BingConversions.TranslateActions = function (actions) {
        var a = new Array();
        actions.forEach(function (x) { return a.push(BingConversions.TranslateAction(x)); });
        return a;
    };
    /**
     * Maps an IBox object to a Microsoft.Maps.LocationRect object.
     *
     * @static
     * @param {IBox} box - Object to be mapped.
     * @returns {Microsoft.Maps.LocationRect} - Mapped object.
     *
     * @memberof BingConversions
     */
    BingConversions.TranslateBounds = function (box) {
        var r = Microsoft.Maps.LocationRect.fromEdges(box.maxLatitude, box.minLongitude, box.minLatitude, box.maxLongitude);
        return r;
    };
    /**
     * Maps an IClusterOptions object to a Microsoft.Maps.IClusterLayerOptions object.
     *
     * @static
     * @param {IClusterOptions} options - Object to be mapped.
     * @returns {Microsoft.Maps.IClusterLayerOptions} - Mapped object.
     *
     * @memberof BingConversions
     */
    BingConversions.TranslateClusterOptions = function (options) {
        var o = {};
        Object.keys(options)
            .filter(function (k) { return BingConversions._clusterOptionsAttributes.indexOf(k) !== -1; })
            .forEach(function (k) {
            if (k === 'layerOffset') {
                o.layerOffset = BingConversions.TranslatePoint(options.layerOffset);
            }
            if (k === 'placementMode') {
                if (options.placementMode === cluster_placement_mode_1.ClusterPlacementMode.FirstPin) {
                    o.placementMode = Microsoft.Maps.ClusterPlacementType.FirstLocation;
                }
                else {
                    o.placementMode = Microsoft.Maps.ClusterPlacementType.MeanAverage;
                }
            }
            else {
                o[k] = options[k];
            }
        });
        return o;
    };
    /**
     * Maps an IInfoWindowOptions object to a Microsoft.Maps.IInfoboxOptions object.
     *
     * @static
     * @param {IInfoWindowOptions} options - Object to be mapped.
     * @returns {Microsoft.Maps.IInfoboxOptions} - Mapped object.
     *
     * @memberof BingConversions
     */
    BingConversions.TranslateInfoBoxOptions = function (options) {
        var o = {};
        Object.keys(options)
            .filter(function (k) { return BingConversions._infoWindowOptionsAttributes.indexOf(k) !== -1; })
            .forEach(function (k) {
            if (k === 'pixelOffset') {
                o.offset = BingConversions.TranslatePoint(options.pixelOffset);
            }
            else if (k === 'position') {
                o.location = BingConversions.TranslateLocation(options.position);
            }
            else if (k === 'actions') {
                o.actions = BingConversions.TranslateActions(options.actions);
            }
            else {
                o[k] = options[k];
            }
        });
        return o;
    };
    /**
     * Maps an IMapOptions object to a Microsoft.Maps.IMapLoadOptions object.
     *
     * @static
     * @param {IMapOptions} options - Object to be mapped.
     * @returns {Microsoft.Maps.IMapLoadOptions} - Mapped object.
     *
     * @memberof BingConversions
     */
    BingConversions.TranslateLoadOptions = function (options) {
        var o = {};
        Object.keys(options)
            .filter(function (k) {
            return BingConversions._mapOptionsAttributes.indexOf(k) !== -1 || BingConversions._viewOptionsAttributes.indexOf(k) !== -1;
        })
            .forEach(function (k) {
            if (k === 'center') {
                o.center = BingConversions.TranslateLocation(options.center);
            }
            else if (k === 'mapTypeId') {
                if (options.mapTypeId === map_type_id_1.MapTypeId.hybrid) {
                    o.mapTypeId = Microsoft.Maps.MapTypeId.aerial;
                    o.labelOverlay = Microsoft.Maps.LabelOverlay.visible;
                }
                else if (options.mapTypeId === map_type_id_1.MapTypeId.aerial) {
                    o.mapTypeId = Microsoft.Maps.MapTypeId.aerial;
                    o.labelOverlay = Microsoft.Maps.LabelOverlay.hidden;
                }
                else {
                    o.mapTypeId = Microsoft.Maps.MapTypeId[map_type_id_1.MapTypeId[options.mapTypeId]];
                }
            }
            else if (k === 'bounds') {
                o.bounds = BingConversions.TranslateBounds(options.bounds);
            }
            else {
                o[k] = options[k];
            }
        });
        return o;
    };
    /**
     * Maps an ILatLong object to a Microsoft.Maps.Location object.
     *
     * @static
     * @param {ILatLong} latlong - Object to be mapped.
     * @returns {Microsoft.Maps.Location} - Mapped object.
     *
     * @memberof BingConversions
     */
    BingConversions.TranslateLocation = function (latlong) {
        var l = new Microsoft.Maps.Location(latlong.latitude, latlong.longitude);
        return l;
    };
    /**
     * Maps an IMarkerOptions object to a Microsoft.Maps.IPushpinOptions object.
     *
     * @static
     * @param {IMarkerOptions} options - Object to be mapped.
     * @returns {Promise<Microsoft.Maps.IPushpinOptions>} - Promise that when resolved contains the mapped object.
     *
     * @memberof BingConversions
     */
    BingConversions.TranslateMarkerOptions = function (options) {
        var o = {};
        var s = null;
        var p = new Promise(function (resolve, reject) {
            Object.keys(options)
                .filter(function (k) { return BingConversions._markerOptionsAttributes.indexOf(k) !== -1; })
                .forEach(function (k) {
                if (k === 'iconInfo') {
                    return;
                }
                else if (k === 'icon') {
                    return;
                }
                else if (k === 'anchor') {
                    o.anchor = BingConversions.TranslatePoint(options.anchor);
                }
                else {
                    o[k] = options[k];
                }
            });
            if (options.iconInfo != null) {
                s = marker_1.Marker.CreateMarker(options.iconInfo);
                if (typeof (s) === 'string') {
                    o.icon = s;
                    resolve(o);
                }
                else {
                    s.then(function (x) {
                        o.icon = x.icon;
                        resolve(o);
                    });
                }
            }
            else {
                if (options.icon) {
                    o.icon = options.icon;
                }
                resolve(o);
            }
        });
        return p;
    };
    /**
     * Maps an IMapOptions object to a Microsoft.Maps.IMapOptions object.
     *
     * @static
     * @param {IMapOptions} options - Object to be mapped.
     * @returns {Microsoft.Maps.IMapOptions} - Mapped object.
     *
     * @memberof BingConversions
     */
    BingConversions.TranslateOptions = function (options) {
        var o = {};
        Object.keys(options)
            .filter(function (k) { return BingConversions._mapOptionsAttributes.indexOf(k) !== -1; })
            .forEach(function (k) {
            if (k === 'center') {
                o.center = BingConversions.TranslateLocation(options.center);
            }
            else if (k === 'mapTypeId') {
                o.mapTypeId = Microsoft.Maps.MapTypeId[map_type_id_1.MapTypeId[options.mapTypeId]];
            }
            else {
                o[k] = options[k];
            }
        });
        return o;
    };
    /**
     * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations
     *
     * @static
     * @param {(Array<ILatLong> | Array<Array<ILatLong>>)} paths - ILatLong based locations to convert.
     * @returns {Array<Array<Microsoft.Maps.Location>>} - converted locations.
     *
     * @memberof BingConversions
     */
    BingConversions.TranslatePaths = function (paths) {
        var p = new Array();
        if (paths == null || !Array.isArray(paths) || paths.length === 0) {
            p.push(new Array());
        }
        else if (Array.isArray(paths[0])) {
            // parameter is an array or arrays
            paths.forEach(function (path) {
                var _p = new Array();
                path.forEach(function (x) { return _p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)); });
                p.push(_p);
            });
        }
        else {
            // parameter is a simple array....
            var y_1 = new Array();
            paths.forEach(function (x) { return y_1.push(new Microsoft.Maps.Location(x.latitude, x.longitude)); });
            p.push(y_1);
        }
        return p;
    };
    /**
     *  Maps an IPoint object to a Microsoft.Maps.Point object.
     *
     * @static
     * @param {IPoint} point - Object to be mapped.
     * @returns {Microsoft.Maps.Point} - Mapped object.
     *
     * @memberof BingConversions
     */
    BingConversions.TranslatePoint = function (point) {
        var p = new Microsoft.Maps.Point(point.x, point.y);
        return p;
    };
    /**
     *  Maps an IPolygonOptions object to a Microsoft.Maps.IPolygonOptions.
     *
     * @static
     * @param {IPolygonOptions} options - Object to be mapped.
     * @returns {Microsoft.Maps.IPolygonOptions} - Mapped object.
     *
     * @memberof BingConversions
     */
    BingConversions.TranslatePolygonOptions = function (options) {
        var o = {};
        var f = function (s, a) {
            var m = /rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*\d+[\.\d+]*)*\)/g.exec(s);
            if (m && m.length > 3) {
                a = a > 1 ? (a / 100) : a;
                return 'rgba(' + [m[1], m[2], m[3], a].join(',') + ')';
            }
            else if (s[0] === '#') {
                var x = Math.floor(a * 255);
                var y = x.toString(16);
                var z = s.substr(0);
                if (z.length > 7) {
                    z = z.substr(0, 7);
                }
                if (x < 16) {
                    y = y + '0';
                }
                return z + y;
            }
            else {
                return s;
            }
        };
        Object.keys(options)
            .filter(function (k) { return BingConversions._polygonOptionsAttributes.indexOf(k) !== -1; })
            .forEach(function (k) {
            if (k === 'strokeWeight') {
                o.strokeThickness = options.strokeWeight;
            }
            else if (k === 'strokeColor') {
                if (options.strokeOpacity) {
                    o.strokeColor = f(options.strokeColor, options.strokeOpacity);
                }
                else {
                    o.strokeColor = options.strokeColor;
                }
            }
            else if (k === 'strokeOpacity') {
            }
            else if (k === 'fillColor') {
                if (options.fillOpacity) {
                    o.fillColor = f(options.fillColor, options.fillOpacity);
                }
                else {
                    o.fillColor = options.fillColor;
                }
            }
            else if (k === 'fillOpacity') { }
            else {
                o[k] = options[k];
            }
        });
        return o;
    };
    /**
     *  Maps an IPolylineOptions object to a Microsoft.Maps.IPolylineOptions.
     *
     * @static
     * @param {IPolylineOptions} options - Object to be mapped.
     * @returns {Microsoft.Maps.IPolylineOptions} - Mapped object.
     *
     * @memberof BingConversions
     */
    BingConversions.TranslatePolylineOptions = function (options) {
        var o = {};
        var f = function (s, a) {
            var m = /rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*\d+[\.\d+]*)*\)/g.exec(s);
            if (m && m.length > 3) {
                a = a > 1 ? (a / 100) : a;
                return 'rgba(' + [m[1], m[2], m[3], a].join(',') + ')';
            }
            else if (s[0] === '#') {
                var x = Math.floor(a * 255);
                var y = x.toString(16);
                var z = s.substr(0);
                if (z.length > 7) {
                    z = z.substr(0, 7);
                }
                if (x < 16) {
                    y = y + '0';
                }
                return z + y;
            }
            else {
                return s;
            }
        };
        Object.keys(options)
            .filter(function (k) { return BingConversions._polylineOptionsAttributes.indexOf(k) !== -1; })
            .forEach(function (k) {
            if (k === 'strokeWeight') {
                o.strokeThickness = options.strokeWeight;
            }
            else if (k === 'strokeColor') {
                if (options.strokeOpacity) {
                    o.strokeColor = f(options.strokeColor, options.strokeOpacity);
                }
                else {
                    o.strokeColor = options.strokeColor;
                }
            }
            else if (k === 'strokeOpacity') {
            }
            else {
                o[k] = options[k];
            }
        });
        return o;
    };
    /**
     * Maps an IMapOptions object to a Microsoft.Maps.IViewOptions object.
     *
     * @static
     * @param {IMapOptions} options - Object to be mapped.
     * @returns {Microsoft.Maps.IViewOptions} - Mapped object.
     *
     * @memberof BingConversions
     */
    BingConversions.TranslateViewOptions = function (options) {
        var o = {};
        Object.keys(options)
            .filter(function (k) { return BingConversions._viewOptionsAttributes.indexOf(k) !== -1; })
            .forEach(function (k) {
            if (k === 'center') {
                o.center = BingConversions.TranslateLocation(options.center);
            }
            else if (k === 'bounds') {
                o.bounds = BingConversions.TranslateBounds(options.bounds);
            }
            else if (k === 'centerOffset') {
                o.centerOffset = BingConversions.TranslatePoint(options.centerOffset);
            }
            else if (k === 'mapTypeId') {
                o.mapTypeId = Microsoft.Maps.MapTypeId[map_type_id_1.MapTypeId[options.mapTypeId]];
            }
            else {
                o[k] = options[k];
            }
        });
        return o;
    };
    return BingConversions;
}());
///
/// Field declarations
///
/**
 * Map option attributes that are supported for conversion to Bing Map properties
 *
 * @private
 * @static
 * @type {string[]}
 * @memberof BingConversions
 */
BingConversions._mapOptionsAttributes = [
    'backgroundColor',
    'credentials',
    'customizeOverlays',
    'disableBirdseye',
    'disableKeyboardInput',
    'disableMouseInput',
    'disablePanning',
    'disableTouchInput',
    'disableUserInput',
    'disableZooming',
    'disableStreetside',
    'enableClickableLogo',
    'enableSearchLogo',
    'fixedMapPosition',
    'height',
    'inertiaIntensity',
    'navigationBarMode',
    'showBreadcrumb',
    'showCopyright',
    'showDashboard',
    'showMapTypeSelector',
    'showScalebar',
    'theme',
    'tileBuffer',
    'useInertia',
    'width',
    'center',
    'zoom',
    'mapTypeId'
];
/**
 * View option attributes that are supported for conversion to Bing Map properties
 *
 * @private
 * @static
 * @type {string[]}
 * @memberof BingConversions
 */
BingConversions._viewOptionsAttributes = [
    'animate',
    'bounds',
    'center',
    'centerOffset',
    'heading',
    'labelOverlay',
    'mapTypeId',
    'padding',
    'zoom'
];
/**
 * InfoWindow option attributes that are supported for conversion to Bing Map properties
 *
 * @private
 * @static
 * @type {string[]}
 * @memberof BingConversions
 */
BingConversions._infoWindowOptionsAttributes = [
    'actions',
    'description',
    'htmlContent',
    'id',
    'position',
    'pixelOffset',
    'showCloseButton',
    'showPointer',
    'pushpin',
    'title',
    'titleClickHandler',
    'typeName',
    'visible',
    'width',
    'height'
];
/**
 * Marker option attributes that are supported for conversion to Bing Map properties
 *
 * @private
 * @static
 * @type {string[]}
 * @memberof BingConversions
 */
BingConversions._markerOptionsAttributes = [
    'anchor',
    'draggable',
    'height',
    'htmlContent',
    'icon',
    'iconInfo',
    'infobox',
    'state',
    'title',
    'textOffset',
    'typeName',
    'visible',
    'width',
    'zIndex'
];
/**
 * Polygon option attributes that are supported for conversion to Bing Map Polygon properties
 *
 * @private
 * @static
 * @type {string[]}
 * @memberof BingConversions
 */
BingConversions._polygonOptionsAttributes = [
    'cursor',
    'fillColor',
    'fillOpacity',
    'strokeColor',
    'strokeOpacity',
    'strokeWeight',
    'visible'
];
/**
 * Polyline option attributes that are supported for conversion to Bing Map Polyline properties
 *
 * @private
 * @static
 * @type {string[]}
 * @memberof BingConversions
 */
BingConversions._polylineOptionsAttributes = [
    'cursor',
    'strokeColor',
    'strokeOpacity',
    'strokeWeight',
    'visible'
];
/**
 * Cluster option attributes that are supported for conversion to Bing Map properties
 *
 * @private
 * @static
 * @type {string[]}
 * @memberof BingConversions
 */
BingConversions._clusterOptionsAttributes = [
    'callback',
    'clusteredPinCallback',
    'clusteringEnabled',
    'gridSize',
    'layerOffset',
    'placementMode',
    'visible',
    'zIndex'
];
exports.BingConversions = BingConversions;
//# sourceMappingURL=bing-conversions.js.map