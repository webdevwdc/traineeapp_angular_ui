"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var bing_polygon_1 = require("./../../models/bing/bing-polygon");
var bing_polyline_1 = require("./../../models/bing/bing-polyline");
var map_service_1 = require("./../map.service");
var bing_layer_base_1 = require("./bing-layer-base");
var bing_conversions_1 = require("./bing-conversions");
/**
 * Implements the {@link LayerService} contract for a  Bing Maps V8 specific implementation.
 *
 * @export
 * @class BingLayerService
 * @extends {BingLayerBase}
 * @implements {LayerService}
 */
var BingLayerService = (function (_super) {
    __extends(BingLayerService, _super);
    ///
    /// Constructor
    ///
    /**
     * Creates an instance of BingLayerService.
     * @param {MapService} _mapService - Instance of the Bing Maps Service. Will generally be injected.
     * @param {NgZone} _zone - NgZone instance to provide zone aware promises.
     *
     * @memberof BingLayerService
     */
    function BingLayerService(_mapService, _zone) {
        var _this = _super.call(this, _mapService) || this;
        _this._zone = _zone;
        ///
        /// Field Declarations.
        ///
        _this._layers = new Map();
        return _this;
    }
    /**
     * Adds a layer to the map.
     *
     * @abstract
     * @param {MapLayerDirective} layer - MapLayerDirective component object.
     * Generally, MapLayerDirective will be injected with an instance of the
     * LayerService and then self register on initialization.
     *
     * @memberof BingLayerService
     */
    BingLayerService.prototype.AddLayer = function (layer) {
        var layerPromise = this._mapService.CreateLayer({ id: layer.Id });
        this._layers.set(layer, layerPromise);
    };
    /**
     * Adds a polygon to the layer.
     *
     * @abstract
     * @param {number} layer - The id of the layer to which to add the polygon.
     * @param {IPolygonOptions} options - Polygon options defining the polygon.
     * @returns {Promise<Polygon>} - A promise that when fullfilled contains the an instance of the Polygon model.
     *
     * @memberof BingLayerService
     */
    BingLayerService.prototype.CreatePolygon = function (layer, options) {
        var _this = this;
        var p = this.GetLayerById(layer);
        if (p == null) {
            throw (new Error("Layer with id " + layer + " not found in Layer Map"));
        }
        return p.then(function (l) {
            var locs = bing_conversions_1.BingConversions.TranslatePaths(options.paths);
            var o = bing_conversions_1.BingConversions.TranslatePolygonOptions(options);
            var poly = new Microsoft.Maps.Polygon(locs, o);
            var polygon = new bing_polygon_1.BingPolygon(poly, _this._mapService.MapInstance, l.NativePrimitve);
            if (options.title && options.title !== '') {
                polygon.Title = options.title;
            }
            if (options.showLabel != null) {
                polygon.ShowLabel = options.showLabel;
            }
            if (options.showTooltip != null) {
                polygon.ShowTooltip = options.showTooltip;
            }
            if (options.labelMaxZoom != null) {
                polygon.LabelMaxZoom = options.labelMaxZoom;
            }
            if (options.labelMinZoom != null) {
                polygon.LabelMinZoom = options.labelMinZoom;
            }
            l.AddEntity(polygon);
            return polygon;
        });
    };
    /**
     * Adds a polyline to the layer.
     *
     * @abstract
     * @param {number} layer - The id of the layer to which to add the line.
     * @param {IPolylineOptions} options - Polyline options defining the line.
     * @returns {Promise<Polyline|Array<Polyline>>} - A promise that when fullfilled contains the an instance of the Polyline (or an array
     * of polygons for complex paths) model.
     *
     * @memberof BingLayerService
     */
    BingLayerService.prototype.CreatePolyline = function (layer, options) {
        var _this = this;
        var p = this.GetLayerById(layer);
        var polyline;
        var line;
        if (p == null) {
            throw (new Error("Layer with id " + layer + " not found in Layer Map"));
        }
        return p.then(function (l) {
            var locs = bing_conversions_1.BingConversions.TranslatePaths(options.path);
            var o = bing_conversions_1.BingConversions.TranslatePolylineOptions(options);
            if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {
                polyline = new Microsoft.Maps.Polyline(locs[0], o);
                line = new bing_polyline_1.BingPolyline(polyline, _this._mapService.MapInstance, l.NativePrimitve);
                l.AddEntity(line);
                if (options.title && options.title !== '') {
                    line.Title = options.title;
                }
                if (options.showTooltip != null) {
                    line.ShowTooltip = options.showTooltip;
                }
                return line;
            }
            else {
                var lines_1 = new Array();
                locs.forEach(function (x) {
                    polyline = new Microsoft.Maps.Polyline(x, o);
                    line = new bing_polyline_1.BingPolyline(polyline, _this._mapService.MapInstance, l.NativePrimitve);
                    l.AddEntity(line);
                    if (options.title && options.title !== '') {
                        line.Title = options.title;
                    }
                    if (options.showTooltip != null) {
                        line.ShowTooltip = options.showTooltip;
                    }
                    lines_1.push(line);
                });
                return lines_1;
            }
        });
    };
    /**
     * Deletes the layer
     *
     * @abstract
     * @param {MapLayerDirective} layer - MapLayerDirective component object for which to retrieve the layer.
     * @returns {Promise<void>} - A promise that is fullfilled when the layer has been removed.
     *
     * @memberof BingLayerService
     */
    BingLayerService.prototype.DeleteLayer = function (layer) {
        var _this = this;
        var l = this._layers.get(layer);
        if (l == null) {
            return Promise.resolve();
        }
        return l.then(function (l1) {
            return _this._zone.run(function () {
                l1.Delete();
                _this._layers.delete(layer);
            });
        });
    };
    /**
     * Returns the Layer model represented by this layer.
     *
     * @abstract
     * @param {MapLayerDirective} layer - MapLayerDirective component object for which to retrieve the layer model.
     * @returns {Promise<Layer>} - A promise that when resolved contains the Layer model.
     *
     * @memberof BingLayerService
     */
    BingLayerService.prototype.GetNativeLayer = function (layer) {
        return this._layers.get(layer);
    };
    return BingLayerService;
}(bing_layer_base_1.BingLayerBase));
BingLayerService.decorators = [
    { type: core_1.Injectable },
];
/** @nocollapse */
BingLayerService.ctorParameters = function () { return [
    { type: map_service_1.MapService, },
    { type: core_1.NgZone, },
]; };
exports.BingLayerService = BingLayerService;
//# sourceMappingURL=bing-layer.service.js.map