"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var Observable_1 = require("rxjs/Observable");
var Subject_1 = require("rxjs/Subject");
var map_service_1 = require("../map.service");
var layer_service_1 = require("../layer.service");
/**
 * Concrete implementation of the Polygon Service abstract class for Bing Maps V8.
 *
 * @export
 * @class BingPolygonService
 * @implements {PolygonService}
 */
var BingPolygonService = (function () {
    ///
    /// Constructor
    ///
    /**
     * Creates an instance of BingPolygonService.
     * @param {MapService} _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.
     * @param {LayerService} _layerService - {@link BingLayerService} instance.
     * The concrete {@link BingLayerService} implementation is expected.
     * @param {NgZone} _zone - NgZone instance to support zone aware promises.
     *
     * @memberof BingPolygonService
     */
    function BingPolygonService(_mapService, _layerService, _zone) {
        this._mapService = _mapService;
        this._layerService = _layerService;
        this._zone = _zone;
        ///
        /// Field declarations
        ///
        this._polygons = new Map();
    }
    /**
     * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a
     * correcsponding layer.
     *
     * @param {MapPolygonDirective} polygon - The {@link MapPolygonDirective} to be added.
     *
     * @memberof BingPolygonService
     */
    BingPolygonService.prototype.AddPolygon = function (polygon) {
        var o = {
            id: polygon.Id,
            clickable: polygon.Clickable,
            draggable: polygon.Draggable,
            editable: polygon.Editable,
            fillColor: polygon.FillColor,
            fillOpacity: polygon.FillOpacity,
            geodesic: polygon.Geodesic,
            labelMaxZoom: polygon.LabelMaxZoom,
            labelMinZoom: polygon.LabelMinZoom,
            paths: polygon.Paths,
            showLabel: polygon.ShowLabel,
            showTooltip: polygon.ShowTooltip,
            strokeColor: polygon.StrokeColor,
            strokeOpacity: polygon.StrokeOpacity,
            strokeWeight: polygon.StrokeWeight,
            title: polygon.Title,
            visible: polygon.Visible,
            zIndex: polygon.zIndex,
        };
        var polygonPromise;
        if (polygon.InCustomLayer) {
            polygonPromise = this._layerService.CreatePolygon(polygon.LayerId, o);
        }
        else {
            polygonPromise = this._mapService.CreatePolygon(o);
        }
        this._polygons.set(polygon, polygonPromise);
    };
    /**
      * Registers an event delegate for a polygon.
      *
      * @template T - Type of the event to emit.
      * @param {string} eventName - The name of the event to register (e.g. 'click')
      * @param {MapPolygonDirective} polygon - The {@link MapPolygonDirective} for which to register the event.
      * @returns {Observable<T>} - Observable emiting an instance of T each time the event occurs.
      *
      * @memberof BingPolygonService
      */
    BingPolygonService.prototype.CreateEventObservable = function (eventName, polygon) {
        var _this = this;
        var b = new Subject_1.Subject();
        if (eventName === 'mousemove') {
            return b.asObservable();
        }
        if (eventName === 'rightclick') {
            return b.asObservable();
        }
        ///
        /// mousemove and rightclick are not supported by bing polygons.
        ///
        return Observable_1.Observable.create(function (observer) {
            _this._polygons.get(polygon).then(function (p) {
                p.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
            });
        });
    };
    /**
      * Deletes a polygon.
      *
      * @param {MapPolygonDirective} polygon - {@link MapPolygonDirective} to be deleted.
      * @returns {Promise<void>} - A promise fullfilled once the polygon has been deleted.
      *
      * @memberof BingPolygonService
      */
    BingPolygonService.prototype.DeletePolygon = function (polygon) {
        var _this = this;
        var m = this._polygons.get(polygon);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then(function (l) {
            return _this._zone.run(function () {
                l.Delete();
                _this._polygons.delete(polygon);
            });
        });
    };
    ;
    /**
     * Obtains geo coordinates for the polygon on the click location
     *
     * @abstract
     * @param {(MouseEvent| any)} e - The mouse event. Expected to implement {@link Microsoft.Maps.IMouseEventArgs}.
     * @returns {ILatLong} - {@link ILatLong} containing the geo coordinates of the clicked marker.
     *
     * @memberof BingPolygonService
     */
    BingPolygonService.prototype.GetCoordinatesFromClick = function (e) {
        var x = e;
        return { latitude: x.location.latitude, longitude: x.location.longitude };
    };
    ;
    /**
     * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.
     *
     * @param {MapPolygonDirective} polygon - The {@link MapPolygonDirective} for which to obtain the polygon model.
     * @returns {Promise<Polygon>} - A promise that when fullfilled contains the {@link Polygon} implementation of the underlying platform.
     *
     * @memberof BingPolygonService
     */
    BingPolygonService.prototype.GetNativePolygon = function (polygon) {
        return this._polygons.get(polygon);
    };
    /**
     * Set the polygon options.
     *
     * @param {MapPolygonDirective} polygon - {@link MapPolygonDirective} to be updated.
     * @param {IPolygonOptions} options - {@link IPolygonOptions} object containing the options. Options will be merged with the
     * options already on the underlying object.
     * @returns {Promise<void>} - A promise fullfilled once the polygon options have been set.
     *
     * @memberof BingPolygonService
     */
    BingPolygonService.prototype.SetOptions = function (polygon, options) {
        return this._polygons.get(polygon).then(function (l) { l.SetOptions(options); });
    };
    /**
     * Updates the Polygon path
     *
     * @param {MapPolygonDirective} polygon - {@link MapPolygonDirective} to be updated.
     * @returns {Promise<void>} - A promise fullfilled once the polygon has been updated.
     *
     * @memberof BingPolygonService
     */
    BingPolygonService.prototype.UpdatePolygon = function (polygon) {
        var _this = this;
        var m = this._polygons.get(polygon);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then(function (l) { return _this._zone.run(function () { l.SetPaths(polygon.Paths); }); });
    };
    return BingPolygonService;
}());
BingPolygonService.decorators = [
    { type: core_1.Injectable },
];
/** @nocollapse */
BingPolygonService.ctorParameters = function () { return [
    { type: map_service_1.MapService, },
    { type: layer_service_1.LayerService, },
    { type: core_1.NgZone, },
]; };
exports.BingPolygonService = BingPolygonService;
//# sourceMappingURL=bing-polygon.service.js.map