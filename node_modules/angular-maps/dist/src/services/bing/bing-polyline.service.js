"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var Observable_1 = require("rxjs/Observable");
var Subject_1 = require("rxjs/Subject");
var map_service_1 = require("../map.service");
var layer_service_1 = require("../layer.service");
/**
 * Concrete implementation of the Polyline Service abstract class for Bing Maps V8.
 *
 * @export
 * @class BingPolylineService
 * @implements {PolylineService}
 */
var BingPolylineService = (function () {
    ///
    /// Constructor
    ///
    /**
     * Creates an instance of BingPolylineService.
     * @param {MapService} _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.
     * @param {LayerService} _layerService - {@link LayerService} instance.
     * The concrete {@link BingLayerService} implementation is expected.
     * @param {NgZone} _zone - NgZone instance to support zone aware promises.
     *
     * @memberof BingPolylineService
     */
    function BingPolylineService(_mapService, _layerService, _zone) {
        this._mapService = _mapService;
        this._layerService = _layerService;
        this._zone = _zone;
        ///
        /// Field declarations
        ///
        this._polylines = new Map();
    }
    ///
    /// Public members and MarkerService implementation
    ///
    /**
     * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a
     * corresponding layer.
     *
     * @param {MapPolylineDirective} polyline - The {@link MapPolylineDirective} to be added.
     *
     * @memberof BingPolylineService
     */
    BingPolylineService.prototype.AddPolyline = function (polyline) {
        var o = {
            id: polyline.Id,
            clickable: polyline.Clickable,
            draggable: polyline.Draggable,
            editable: polyline.Editable,
            geodesic: polyline.Geodesic,
            path: polyline.Path,
            showTooltip: polyline.ShowTooltip,
            strokeColor: polyline.StrokeColor,
            strokeOpacity: polyline.StrokeOpacity,
            strokeWeight: polyline.StrokeWeight,
            title: polyline.Title,
            visible: polyline.Visible,
            zIndex: polyline.zIndex,
        };
        var polylinePromise;
        if (polyline.InCustomLayer) {
            polylinePromise = this._layerService.CreatePolyline(polyline.LayerId, o);
        }
        else {
            polylinePromise = this._mapService.CreatePolyline(o);
        }
        this._polylines.set(polyline, polylinePromise);
    };
    /**
      * Registers an event delegate for a line.
      *
      * @template T - Type of the event to emit.
      * @param {string} eventName - The name of the event to register (e.g. 'click')
      * @param {MapPolylineDirective} polyline - The {@link MapPolylineDirective} for which to register the event.
      * @returns {Observable<T>} - Observable emiting an instance of T each time the event occurs.
      *
      * @memberof BingPolylineService
      */
    BingPolylineService.prototype.CreateEventObservable = function (eventName, polyline) {
        var _this = this;
        var b = new Subject_1.Subject();
        if (eventName === 'mousemove') {
            return b.asObservable();
        }
        if (eventName === 'rightclick') {
            return b.asObservable();
        }
        ///
        /// mousemove and rightclick are not supported by bing polygons.
        ///
        return Observable_1.Observable.create(function (observer) {
            _this._polylines.get(polyline).then(function (p) {
                var x = Array.isArray(p) ? p : [p];
                x.forEach(function (line) { return line.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); }); });
            });
        });
    };
    /**
      * Deletes a polyline.
      *
      * @param {MapPolylineDirective} polyline - {@link MapPolylineDirective} to be deleted.
      * @returns {Promise<void>} - A promise fullfilled once the polyline has been deleted.
      *
      * @memberof BingPolylineService
      */
    BingPolylineService.prototype.DeletePolyline = function (polyline) {
        var _this = this;
        var m = this._polylines.get(polyline);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then(function (l) {
            return _this._zone.run(function () {
                var x = Array.isArray(l) ? l : [l];
                x.forEach(function (line) { return line.Delete(); });
                _this._polylines.delete(polyline);
            });
        });
    };
    ;
    /**
     * Obtains geo coordinates for the marker on the click location
     *
     * @abstract
     * @param {(MouseEvent| any)} e - The mouse event.
     * @returns {ILatLong} - {@link ILatLong} containing the geo coordinates of the clicked marker.
     *
     * @memberof BingPolylineService
     */
    BingPolylineService.prototype.GetCoordinatesFromClick = function (e) {
        if (!e) {
            return null;
        }
        if (!e.location) {
            return null;
        }
        return { latitude: e.location.latitude, longitude: e.location.longitude };
    };
    ;
    /**
     * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
     *
     * @param {MapPolylineDirective} polyline - The {@link MapPolylineDirective} for which to obtain the polyline model.
     * @returns {Promise<Polyline>} - A promise that when fullfilled contains the {@link Polyline}
     * implementation of the underlying platform. For complex paths, returns an array of polylines.
     *
     * @memberof BingPolylineService
     */
    BingPolylineService.prototype.GetNativePolyline = function (polyline) {
        return this._polylines.get(polyline);
    };
    /**
     * Set the polyline options.
     *
     * @param {MapPolylineDirective} polyline - {@link MapPolylineDirective} to be updated.
     * @param {IPolylineOptions} options - {@link IPolylineOptions} object containing the options. Options will be merged with the
     * options already on the underlying object.
     * @returns {Promise<void>} - A promise fullfilled once the polyline options have been set.
     *
     * @memberof BingPolylineService
     */
    BingPolylineService.prototype.SetOptions = function (polyline, options) {
        return this._polylines.get(polyline).then(function (l) {
            var x = Array.isArray(l) ? l : [l];
            x.forEach(function (line) { return line.SetOptions(options); });
        });
    };
    /**
     * Updates the Polyline path
     *
     * @param {MapPolylineDirective} polyline - {@link MapPolylineDirective} to be updated.
     * @returns {Promise<void>} - A promise fullfilled once the polyline has been updated.
     *
     * @memberof BingPolylineService
     */
    BingPolylineService.prototype.UpdatePolyline = function (polyline) {
        var _this = this;
        var m = this._polylines.get(polyline);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then(function (l) { return _this._zone.run(function () {
            var x = Array.isArray(l) ? l : [l];
            var p = polyline.Path.length > 0 && Array.isArray(polyline.Path[0]) ? polyline.Path :
                [polyline.Path];
            x.forEach(function (line, index) {
                if (p.length > index) {
                    line.SetPath(p[index]);
                }
            });
            if (Array.isArray(l) && l.length > p.length) {
                l.splice(p.length - 1).forEach(function (line) { return line.Delete(); });
            }
        }); });
    };
    return BingPolylineService;
}());
BingPolylineService.decorators = [
    { type: core_1.Injectable },
];
/** @nocollapse */
BingPolylineService.ctorParameters = function () { return [
    { type: map_service_1.MapService, },
    { type: layer_service_1.LayerService, },
    { type: core_1.NgZone, },
]; };
exports.BingPolylineService = BingPolylineService;
//# sourceMappingURL=bing-polyline.service.js.map