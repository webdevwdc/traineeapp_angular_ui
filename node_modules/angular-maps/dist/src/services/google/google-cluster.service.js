"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var marker_1 = require("./../../models/marker");
var marker_type_id_1 = require("./../../models/marker-type-id");
var map_service_1 = require("./../map.service");
var google_layer_base_1 = require("./google-layer-base");
var GoogleClusterService = (function (_super) {
    __extends(GoogleClusterService, _super);
    ///
    /// Constructors
    ///
    /**
     * Creates an instance of GoogleClusterService.
     * @param {MapService} _mapService
     * @param {NgZone} _zone
     * @memberof GoogleClusterService
     */
    function GoogleClusterService(_mapService, _zone) {
        var _this = _super.call(this, _mapService) || this;
        _this._zone = _zone;
        ///
        /// Field declarations
        ///
        _this._layers = new Map();
        _this._layerStyles = new Map();
        return _this;
    }
    ///
    /// Static methods
    ///
    /**
     * Creates the cluster icon from the styles
     *
     * @param {Array<IClusterIconInfo>} styles
     * @returns {Promise<Array<IClusterIconInfo>>} - Promise that when resolved contains an Array of IClusterIconInfo objects
     * containing the hydrated cluster icons.
     * @memberof GoogleClusterService
     */
    GoogleClusterService.CreateClusterIcons = function (styles) {
        var i = new Promise(function (resolve, reject) {
            var pa = new Array();
            styles.forEach(function (style, index) {
                if (style.iconInfo) {
                    var s = marker_1.Marker.CreateMarker(style.iconInfo);
                    if (typeof (s) === 'string') {
                        style.url = s;
                        if (style.width == null) {
                            style.width = style.iconInfo.size.width;
                            style.height = style.iconInfo.size.height;
                        }
                        if (style.iconInfo.markerOffsetRatio && style.iconInfo.size && style.anchor == null) {
                            var o = style.iconInfo;
                            style.anchor = [
                                o.size.width * o.markerOffsetRatio.x,
                                o.size.height * o.markerOffsetRatio.y
                            ];
                        }
                        delete style.iconInfo;
                    }
                    else {
                        s.then(function (x) {
                            style.url = x.icon;
                            if (style.width == null) {
                                style.width = x.iconInfo.size.width;
                                style.height = x.iconInfo.size.height;
                            }
                            if (x.iconInfo.markerOffsetRatio && x.iconInfo.size && style.anchor == null) {
                                var o = x.iconInfo;
                                style.anchor = [
                                    o.size.width * o.markerOffsetRatio.x,
                                    o.size.height * o.markerOffsetRatio.y
                                ];
                            }
                            delete style.iconInfo;
                        });
                        pa.push(s);
                    }
                }
            });
            if (pa.length === 0) {
                resolve(styles);
            }
            else {
                Promise.all(pa).then(function () {
                    resolve(styles);
                });
            }
            ;
        });
        return i;
    };
    /**
     * Adds the cluster layer to the map
     *
     * @param {ClusterLayerDirective} layer
     * @memberof GoogleClusterService
     */
    GoogleClusterService.prototype.AddLayer = function (layer) {
        var _this = this;
        var options = {
            id: layer.Id,
            zoomOnClick: layer.ZoomOnClick
        };
        if (layer.GridSize) {
            options.gridSize = layer.GridSize;
        }
        if (layer.MinimumClusterSize) {
            options.minimumClusterSize = layer.MinimumClusterSize;
        }
        if (layer.Styles) {
            options.styles = layer.Styles;
        }
        if (layer.UseDynamicSizeMarkers) {
            options.styles = null;
            // do not to attempt to setup styles here as the dynamic call back will generate them.
        }
        else {
            options.styles = [{
                    height: 30,
                    width: 35,
                    textColor: 'white',
                    textSize: 11,
                    backgroundPosition: 'center',
                    iconInfo: {
                        markerType: marker_type_id_1.MarkerTypeId.FontMarker,
                        fontName: 'FontAwesome',
                        fontSize: 30,
                        color: 'green',
                        text: '\uF111'
                    }
                }];
        }
        var dynamicClusterCallback = function (markers, numStyles, clusterer) {
            // dynamically ensure that the necessary style for this cluster icon exists and
            // the clusterer is already hooked up to the styles array via pointer, so we only
            // need to update the style. Since the clusterer re-renders a cluster icon is the
            // the marker count changes, we will only need to retain the current icon as opposed
            // to all cluster icon.
            var styles = _this._layerStyles.get(layer.Id);
            var iconInfo = {
                markerType: marker_type_id_1.MarkerTypeId.None
            };
            var icon = layer.CustomMarkerCallback(markers, iconInfo);
            styles[0] = {
                url: "\"data:image/svg+xml;utf8," + icon + "\"",
                height: iconInfo.size.height,
                width: iconInfo.size.width,
                textColor: 'white',
                textSize: 11,
                backgroundPosition: 'center',
            };
            return {
                text: markers.length.toString(),
                index: 1
            };
        };
        var resetStyles = function (clusterer) {
            if (_this._layerStyles.has(layer.Id)) {
                _this._layerStyles.get(layer.Id).splice(0);
            }
            else {
                var styles = new Array();
                styles.push({});
                _this._layerStyles.set(layer.Id, styles);
                clusterer.setStyles(styles);
                // this is important for dynamic styles as the pointer to this array gets passed
                // around key objects in the clusterer. Therefore, it must be initialized here in order for
                // updates to the styles to be visible.
                // also, we need to add at least one style to prevent the default styles from being picked up.
            }
        };
        var layerPromise = this._mapService.CreateClusterLayer(options);
        this._layers.set(layer, layerPromise);
        layerPromise.then(function (l) {
            var clusterer = l.NativePrimitve;
            if (options.styles) {
                var s = GoogleClusterService.CreateClusterIcons(options.styles);
                s.then(function (x) {
                    clusterer.setStyles(x);
                });
            }
            else {
                resetStyles(clusterer);
                _this._mapService.MapPromise.then(function (m) {
                    m.addListener('zoom_changed', function () {
                        resetStyles(clusterer);
                    });
                });
                clusterer.setCalculator(function (m, n) {
                    return dynamicClusterCallback(m, n, clusterer);
                });
            }
        });
    };
    ;
    /**
     * Returns the native layer
     *
     * @param {ClusterLayerDirective} layer
     * @returns {Promise<Layer>}
     * @memberof GoogleClusterService
     */
    GoogleClusterService.prototype.GetNativeLayer = function (layer) {
        return this._layers.get(layer);
    };
    ;
    /**
     * Delets the native layer
     *
     * @param {ClusterLayerDirective} layer
     * @returns {Promise<void>}
     * @memberof GoogleClusterService
     */
    GoogleClusterService.prototype.DeleteLayer = function (layer) {
        this._layers.delete(layer);
        return Promise.resolve();
    };
    ;
    /**
     * Create a marker in the cluster
     *
     * @param {number} layer
     * @param {IMarkerOptions} options
     * @returns {Promise<Marker>}
     * @memberof GoogleClusterService
     */
    GoogleClusterService.prototype.CreateMarker = function (layer, options) {
        var _this = this;
        var p = this.GetLayerById(layer);
        if (p == null) {
            throw (new Error("Layer with id " + layer + " not found in Layer Map"));
        }
        return p.then(function (l) {
            return _this._mapService.CreateMarker(options)
                .then(function (marker) {
                marker.IsFirst = options.isFirst;
                marker.IsLast = options.isLast;
                l.AddEntity(marker);
                return marker;
            });
        });
    };
    ;
    /**
     * Starts the clustering
     *
     * @param {ClusterLayerDirective} layer
     * @returns {Promise<void>}
     * @memberof GoogleClusterService
     */
    GoogleClusterService.prototype.StartClustering = function (layer) {
        return Promise.resolve();
    };
    /**
     * Stops the clustering
     *
     * @param {ClusterLayerDirective} layer
     * @returns {Promise<void>}
     * @memberof GoogleClusterService
     */
    GoogleClusterService.prototype.StopClustering = function (layer) {
        return Promise.resolve();
    };
    /**
     * Adds a polygon to the layer.
     *
     * @abstract
     * @param {number} layer - The id of the layer to which to add the polygon.
     * @param {IPolygonOptions} options - Polygon options defining the polygon.
     * @returns {Promise<Polygon>} - A promise that when fullfilled contains the an instance of the Polygon model.
     *
     * @memberof GoogleClusterService
     */
    GoogleClusterService.prototype.CreatePolygon = function (layer, options) {
        throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));
    };
    /**
     * Adds a polyline to the layer.
     *
     * @abstract
     * @param {number} layer - The id of the layer to which to add the line.
     * @param {IPolylineOptions} options - Polyline options defining the line.
     * @returns {Promise<Polyline|Array<Polyline>} - A promise that when fullfilled contains the an instance of the Polyline (or an
     * array of polygons for complex paths) model.
     *
     * @memberof GoogleClusterService
     */
    GoogleClusterService.prototype.CreatePolyline = function (layer, options) {
        throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));
    };
    return GoogleClusterService;
}(google_layer_base_1.GoogleLayerBase));
GoogleClusterService.decorators = [
    { type: core_1.Injectable },
];
/** @nocollapse */
GoogleClusterService.ctorParameters = function () { return [
    { type: map_service_1.MapService, },
    { type: core_1.NgZone, },
]; };
exports.GoogleClusterService = GoogleClusterService;
//# sourceMappingURL=google-cluster.service.js.map