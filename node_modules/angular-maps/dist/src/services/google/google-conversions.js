"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var GoogleMapTypes = require("./google-map-types");
var map_type_id_1 = require("../../models/map-type-id");
/**
 * This class contains helperfunctions to map various interfaces used to represent options and structures into the
 * corresponding Google Maps specific implementations.
 *
 * @export
 * @class GoogleConversions
 */
var GoogleConversions = (function () {
    function GoogleConversions() {
    }
    /**
     * Maps an IBox object to a GoogleMapTypes.LatLngBoundsLiteral object.
     *
     * @static
     * @param {IBox} box - Object to be mapped.
     * @returns {GoogleMapTypes.LatLngBoundsLiteral} - Mapped object.
     *
     * @memberof GoogleConversions
     */
    GoogleConversions.TranslateBounds = function (bounds) {
        var b = {
            east: bounds.maxLongitude,
            north: bounds.maxLatitude,
            south: bounds.minLatitude,
            west: bounds.minLongitude,
        };
        return b;
    };
    /**
     * Maps an IInfoWindowOptions object to a GoogleMapTypes.InfoWindowOptions object.
     *
     * @static
     * @param {IInfoWindowOptions} options - Object to be mapped.
     * @returns {GoogleMapTypes.InfoWindowOptions} - Mapped object.
     *
     * @memberof GoogleConversions
     */
    GoogleConversions.TranslateInfoWindowOptions = function (options) {
        var o = {};
        Object.keys(options)
            .filter(function (k) { return GoogleConversions._infoWindowOptionsAttributes.indexOf(k) !== -1; })
            .forEach(function (k) {
            if (k === 'htmlContent') {
                o.content = options[k];
            }
            else {
                o[k] = options[k];
            }
            ;
        });
        if (o.content == null || o.content === '') {
            if (options.title !== '' && options.description !== '') {
                o.content = options.title + ": " + options.description;
            }
            else if (options.description !== '') {
                o.content = options.description;
            }
            else {
                o.content = options.title;
            }
        }
        return o;
    };
    /**
     * Maps an ILatLong object to a GoogleMapTypes.LatLngLiteral object.
     *
     * @static
     * @param {ILatLong} latlong - Object to be mapped.
     * @returns {GoogleMapTypes.LatLngLiteral} - Mapped object.
     *
     * @memberof GoogleConversions
     */
    GoogleConversions.TranslateLocation = function (latlong) {
        var l = { lat: latlong.latitude, lng: latlong.longitude };
        return l;
    };
    /**
     * Maps an GoogleMapTypes.LatLngLiteral object to a ILatLong object.
     *
     * @static
     * @param {GoogleMapTypes.LatLngLiteral} latlong - Object to be mapped.
     * @returns {ILatLong} - Mapped object.
     *
     * @memberof GoogleConversions
     */
    GoogleConversions.TranslateLatLng = function (latlng) {
        var l = { latitude: latlng.lat, longitude: latlng.lng };
        return l;
    };
    /**
     * Maps an ILatLong object to a GoogleMapTypes.LatLng object.
     *
     * @static
     * @param {ILatLong} latlong - Object to be mapped.
     * @returns {GoogleMapTypes.LatLng} - Mapped object.
     *
     * @memberof GoogleConversions
     */
    GoogleConversions.TranslateLocationObject = function (latlong) {
        var l = new google.maps.LatLng(latlong.latitude, latlong.longitude);
        return l;
    };
    /**
     * Maps an GoogleMapTypes.LatLng object to a ILatLong object.
     *
     * @static
     * @param {GoogleMapTypes.LatLng} latlong - Object to be mapped.
     * @returns {ILatLong} - Mapped object.
     *
     * @memberof GoogleConversions
     */
    GoogleConversions.TranslateLatLngObject = function (latlng) {
        var l = { latitude: latlng.lat(), longitude: latlng.lng() };
        return l;
    };
    /**
     * Maps an ILatLong array to a array of GoogleMapTypes.LatLng object.
     *
     * @static
     * @param {Array<ILatLong>} latlongArray - Object to be mapped.
     * @returns {Array<GoogleMapTypes.LatLng>} - Mapped object.
     *
     * @memberof GoogleConversions
     */
    GoogleConversions.TranslateLocationObjectArray = function (latlongArray) {
        var p = new Array();
        latlongArray.forEach(function (x) { return p.push(GoogleConversions.TranslateLocationObject(x)); });
        return p;
    };
    /**
     * Maps a MapTypeId object to a Google maptype string.
     *
     * @static
     * @param {MapTypeId} mapTypeId - Object to be mapped.
     * @returns {string} - Mapped object.
     *
     * @memberof GoogleConversions
     */
    GoogleConversions.TranslateMapTypeId = function (mapTypeId) {
        switch (mapTypeId) {
            case map_type_id_1.MapTypeId.road: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.roadmap];
            case map_type_id_1.MapTypeId.grayscale: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.terrain];
            case map_type_id_1.MapTypeId.hybrid: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.hybrid];
            case map_type_id_1.MapTypeId.ordnanceSurvey: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.terrain];
            default: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.satellite];
        }
    };
    /**
     * Maps an IMarkerOptions object to a GoogleMapTypes.MarkerOptions object.
     *
     * @static
     * @param {IMarkerOptions} options - Object to be mapped.
     * @returns {GoogleMapTypes.MarkerOptions} - Promise that when resolved contains the mapped object.
     *
     * @memberof GoogleConversions
     */
    GoogleConversions.TranslateMarkerOptions = function (options) {
        var o = {};
        Object.keys(options)
            .filter(function (k) { return GoogleConversions._markerOptionsAttributes.indexOf(k) !== -1; })
            .forEach(function (k) {
            if (k === 'position') {
                var latlng = GoogleConversions.TranslateLocationObject(options[k]);
                o.position = latlng;
            }
            else {
                o[k] = options[k];
            }
            ;
        });
        return o;
    };
    /**
     * Maps an IMapOptions object to a GoogleMapTypes.MapOptions object.
     *
     * @static
     * @param {IMapOptions} options - Object to be mapped.
     * @returns {GoogleMapTypes.MapOptions} - Mapped object.
     *
     * @memberof GoogleConversions
     */
    GoogleConversions.TranslateOptions = function (options) {
        var o = {};
        Object.keys(options)
            .filter(function (k) { return GoogleConversions._mapOptionsAttributes.indexOf(k) !== -1; })
            .forEach(function (k) {
            if (k === 'center') {
                o.center = GoogleConversions.TranslateLocation(options.center);
            }
            else if (k === 'mapTypeId') {
                o.mapTypeId = GoogleConversions.TranslateMapTypeId(options.mapTypeId);
            }
            else {
                o[k] = options[k];
            }
            ;
        });
        return o;
    };
    /**
     * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations
     *
     * @static
     * @param {(Array<ILatLong> | Array<Array<ILatLong>>)} paths - ILatLong based locations to convert.
     * @returns {Array<Array<GoogleMapTypes.LatLng>>} - converted locations.
     *
     * @memberof GoogleConversions
     */
    GoogleConversions.TranslatePaths = function (paths) {
        var p = new Array();
        if (paths == null || !Array.isArray(paths) || paths.length === 0) {
            p.push(new Array());
        }
        else if (Array.isArray(paths[0])) {
            // parameter is an array or arrays
            paths.forEach(function (path) {
                p.push(GoogleConversions.TranslateLocationObjectArray(path));
            });
        }
        else {
            // parameter is a simple array....
            p.push(GoogleConversions.TranslateLocationObjectArray(paths));
        }
        return p;
    };
    /**
     *  Maps an IPolygonOptions object to a GoogleMapTypes.PolygonOptions.
     *
     * @static
     * @param {IPolygonOptions} options - Object to be mapped.
     * @returns {GoogleMapTypes.PolygonOptions} - Mapped object.
     *
     * @memberof GoogleConversions
     */
    GoogleConversions.TranslatePolygonOptions = function (options) {
        var o = {};
        Object.keys(options)
            .filter(function (k) { return GoogleConversions._polygonOptionsAttributes.indexOf(k) !== -1; })
            .forEach(function (k) {
            if (k === 'paths') {
                if (!Array.isArray(options.paths)) {
                    return;
                }
                if (options.paths.length === 0) {
                    o.paths = new Array();
                }
                else if (Array.isArray(options.paths[0])) {
                    o.paths = new Array();
                    options.paths.forEach(function (path) {
                        o.paths.push(GoogleConversions.TranslateLocationObjectArray(path));
                    });
                }
                else {
                    o.paths = GoogleConversions.TranslateLocationObjectArray(options.paths);
                }
            }
            else {
                o[k] = options[k];
            }
            ;
        });
        return o;
    };
    /**
     *  Maps an IPolylineOptions object to a GoogleMapTypes.PolylineOptions.
     *
     * @static
     * @param {IPolylineOptions} options - Object to be mapped.
     * @returns {GoogleMapTypes.PolylineOptions} - Mapped object.
     *
     * @memberof GoogleConversions
     */
    GoogleConversions.TranslatePolylineOptions = function (options) {
        var o = {};
        Object.keys(options)
            .filter(function (k) { return GoogleConversions._polylineOptionsAttributes.indexOf(k) !== -1; })
            .forEach(function (k) {
            o[k] = options[k];
        });
        return o;
    };
    return GoogleConversions;
}());
///
/// Field declarations
///
/**
 * Map option attributes that are supported for conversion to Google Map properties
 *
 * @type string[]
 * @memberof GoogleConversions
 * @private
 * @static
 */
GoogleConversions._mapOptionsAttributes = [
    'backgroundColor',
    'center',
    'clickableIcons',
    'disableDefaultUI',
    'disableDoubleClickZoom',
    'draggable',
    'draggableCursor',
    'draggingCursor',
    'fullscreenControl',
    'fullscreenControlOptions',
    'gestureHandling',
    'heading',
    'keyboardShortcuts',
    'mapTypeControl',
    'mapTypeControlOptions',
    'mapTypeId',
    'maxZoom',
    'minZoom',
    'noClear',
    'panControl',
    'panControlOptions',
    'rotateControl',
    'rotateControlOptions',
    'scaleControl',
    'scaleControlOptions',
    'scrollwheel',
    'streetView',
    'streetViewControl',
    'streetViewControlOptions',
    'styles',
    'tilt',
    'zoom',
    'zoomControl',
    'zoomControlOptions'
];
/**
 * InfoWindow option attributes that are supported for conversion to Google Map properties
 *
 * @type string[]
 * @memberof GoogleConversions
 * @private
 * @static
 */
GoogleConversions._infoWindowOptionsAttributes = [
    'actions',
    'description',
    'htmlContent',
    'id',
    'position',
    'pixelOffset',
    'showCloseButton',
    'showPointer',
    'pushpin',
    'title',
    'titleClickHandler',
    'typeName',
    'visible',
    'width',
    'height'
];
/**
 * Marker option attributes that are supported for conversion to Google Map properties
 *
 * @type string[]
 * @memberof GoogleConversions
 * @private
 * @static
 */
GoogleConversions._markerOptionsAttributes = [
    'anchor',
    'position',
    'title',
    'text',
    'label',
    'draggable',
    'icon',
    'width',
    'height',
    'iconInfo',
    'metadata',
    'visible'
];
/**
 * Cluster option attributes that are supported for conversion to Google Map properties
 *
 * @type string[]
 * @memberof GoogleConversions
 * @private
 * @static
 */
GoogleConversions._clusterOptionsAttributes = [
    'callback',
    'clusteredPinCallback',
    'clusteringEnabled',
    'gridSize',
    'layerOffset',
    'placementMode',
    'visible',
    'zIndex'
];
/**
 * Polygon option attributes that are supported for conversion to Google Map properties
 *
 * @type string[]
 * @memberof GoogleConversions
 * @private
 * @static
 */
GoogleConversions._polygonOptionsAttributes = [
    'clickable',
    'draggable',
    'editable',
    'fillColor',
    'fillOpacity',
    'geodesic',
    'paths',
    'strokeColor',
    'strokeOpacity',
    'strokeWeight',
    'visible',
    'zIndex'
];
/**
 * Polyline option attributes that are supported for conversion to Google Map properties
 *
 * @type string[]
 * @memberof GoogleConversions
 * @private
 * @static
 */
GoogleConversions._polylineOptionsAttributes = [
    'clickable',
    'draggable',
    'editable',
    'geodesic',
    'strokeColor',
    'strokeOpacity',
    'strokeWeight',
    'visible',
    'zIndex'
];
exports.GoogleConversions = GoogleConversions;
//# sourceMappingURL=google-conversions.js.map