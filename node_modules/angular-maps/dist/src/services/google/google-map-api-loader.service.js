"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var mapapiloader_1 = require("../mapapiloader");
/**
 * Protocol enumeration
 *
 * @export
 * @enum {number}
 */
var ScriptProtocol;
(function (ScriptProtocol) {
    ScriptProtocol[ScriptProtocol["HTTP"] = 0] = "HTTP";
    ScriptProtocol[ScriptProtocol["HTTPS"] = 1] = "HTTPS";
    ScriptProtocol[ScriptProtocol["AUTO"] = 2] = "AUTO";
})(ScriptProtocol = exports.ScriptProtocol || (exports.ScriptProtocol = {}));
/**
 * Bing Maps V8 specific loader configuration to be used with the {@link GoogleMapAPILoader}
 *
 * @export
 * @class GoogleMapAPILoaderConfig
 */
var GoogleMapAPILoaderConfig = (function () {
    function GoogleMapAPILoaderConfig() {
    }
    return GoogleMapAPILoaderConfig;
}());
GoogleMapAPILoaderConfig.decorators = [
    { type: core_1.Injectable },
];
/** @nocollapse */
GoogleMapAPILoaderConfig.ctorParameters = function () { return []; };
exports.GoogleMapAPILoaderConfig = GoogleMapAPILoaderConfig;
/**
 * Default loader configuration.
 */
var DEFAULT_CONFIGURATION = new GoogleMapAPILoaderConfig();
/**
 * Bing Maps V8 implementation for the {@link MapAPILoader} service.
 *
 * @export
 * @class GoogleMapAPILoader
 * @extends {MapAPILoader}
 */
var GoogleMapAPILoader = (function (_super) {
    __extends(GoogleMapAPILoader, _super);
    /**
     * Creates an instance of GoogleMapAPILoader.
     * @param {GoogleMapAPILoaderConfig} _config  - The loader configuration.
     * @param {WindowRef} _windowRef - An instance of {@link WindowRef}. Necessary because Bing Map V8 interacts with the window object.
     * @param {DocumentRef} _documentRef - An instance of {@link DocumentRef}.
     *                                     Necessary because Bing Map V8 interacts with the document object.
     * @memberof GoogleMapAPILoader
     */
    function GoogleMapAPILoader(_config, _windowRef, _documentRef) {
        var _this = _super.call(this) || this;
        _this._config = _config;
        _this._windowRef = _windowRef;
        _this._documentRef = _documentRef;
        if (_this._config === null || _this._config === undefined) {
            _this._config = DEFAULT_CONFIGURATION;
        }
        return _this;
    }
    Object.defineProperty(GoogleMapAPILoader.prototype, "Config", {
        ///
        /// Property declarations.
        ///
        /**
         * Gets the loader configuration.
         *
         * @readonly
         * @type {GoogleMapAPILoaderConfig}
         * @memberof GoogleMapAPILoader
         */
        get: function () { return this._config; },
        enumerable: true,
        configurable: true
    });
    ///
    /// Public methods and MapAPILoader implementation.
    ///
    /**
     * Loads the necessary resources for Bing Maps V8.
     *
     * @returns {Promise<void>}
     *
     * @memberof GoogleMapAPILoader
     */
    GoogleMapAPILoader.prototype.Load = function () {
        var _this = this;
        if (this._scriptLoadingPromise) {
            return this._scriptLoadingPromise;
        }
        var script = this._documentRef.GetNativeDocument().createElement('script');
        script.type = 'text/javascript';
        script.async = true;
        script.defer = true;
        var callbackName = "Create";
        script.src = this.GetMapsScriptSrc(callbackName);
        this._scriptLoadingPromise = new Promise(function (resolve, reject) {
            _this._windowRef.GetNativeWindow()[callbackName] = function () {
                if (_this._config.enableClustering) {
                    // if clustering is enabled then delay the loading until after the cluster library is loaded
                    var clusterScript = _this._documentRef.GetNativeDocument().createElement('script');
                    clusterScript.type = 'text/javascript';
                    clusterScript.src = _this.GetClusterScriptSrc();
                    clusterScript.onload = clusterScript.onreadystatechange = function () {
                        resolve();
                    };
                    _this._documentRef.GetNativeDocument().head.appendChild(clusterScript);
                }
                else {
                    resolve();
                }
            };
            script.onerror = function (error) { reject(error); };
        });
        this._documentRef.GetNativeDocument().head.appendChild(script);
        return this._scriptLoadingPromise;
    };
    ///
    /// Private methods
    ///
    /**
     * Gets the Google Maps scripts url for injections into the header.
     *
     * @private
     * @param {string} callbackName - Name of the function to be called when the Google Maps scripts are loaded.
     * @returns {string} - The url to be used to load the Google Map scripts.
     *
     * @memberof GoogleMapAPILoader
     */
    GoogleMapAPILoader.prototype.GetMapsScriptSrc = function (callbackName) {
        var hostAndPath = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';
        var queryParams = {
            v: this._config.apiVersion || '3',
            callback: callbackName,
            key: this._config.apiKey,
            client: this._config.clientId,
            channel: this._config.channel,
            libraries: this._config.libraries,
            region: this._config.region,
            language: this._config.language
        };
        return this.GetScriptSrc(hostAndPath, queryParams);
    };
    /**
     * Gets the Google Maps Cluster library url for injections into the header.
     *
     * @private
     * @returns {string} - The url to be used to load the Google Map Cluster library.
     *
     * @memberof GoogleMapAPILoader
     */
    GoogleMapAPILoader.prototype.GetClusterScriptSrc = function () {
        var hostAndPath = this._config.clusterHostAndPath ||
            'developers.google.com/maps/documentation/javascript/examples/markerclusterer/markerclusterer.js';
        return this.GetScriptSrc(hostAndPath, {});
    };
    /**
     * Gets a scripts url for injections into the header.
     *
     * @private
     * @param {string} hostAndPath - Host and path name of the script to load.
     * @param {{ [key: string]: string | Array<string> }} queryParams - Url query parameters.
     * @returns {string} - The url with correct protocol, path, and query parameters.
     *
     * @memberof GoogleMapAPILoader
     */
    GoogleMapAPILoader.prototype.GetScriptSrc = function (hostAndPath, queryParams) {
        var protocolType = ((this._config && this._config.protocol) || ScriptProtocol.HTTPS);
        var protocol;
        switch (protocolType) {
            case ScriptProtocol.AUTO:
                protocol = '';
                break;
            case ScriptProtocol.HTTP:
                protocol = 'http:';
                break;
            case ScriptProtocol.HTTPS:
                protocol = 'https:';
                break;
        }
        var params = Object.keys(queryParams)
            .filter(function (k) { return queryParams[k] != null; })
            .filter(function (k) {
            // remove empty arrays
            return !Array.isArray(queryParams[k]) ||
                (Array.isArray(queryParams[k]) && queryParams[k].length > 0);
        })
            .map(function (k) {
            // join arrays as comma seperated strings
            var i = queryParams[k];
            if (Array.isArray(i)) {
                return { key: k, value: i.join(',') };
            }
            return { key: k, value: queryParams[k] };
        })
            .map(function (entry) { return entry.key + "=" + entry.value; })
            .join('&');
        return protocol + "//" + hostAndPath + "?" + params;
    };
    return GoogleMapAPILoader;
}(mapapiloader_1.MapAPILoader));
GoogleMapAPILoader.decorators = [
    { type: core_1.Injectable },
];
/** @nocollapse */
GoogleMapAPILoader.ctorParameters = function () { return [
    { type: GoogleMapAPILoaderConfig, decorators: [{ type: core_1.Optional },] },
    { type: mapapiloader_1.WindowRef, },
    { type: mapapiloader_1.DocumentRef, },
]; };
exports.GoogleMapAPILoader = GoogleMapAPILoader;
//# sourceMappingURL=google-map-api-loader.service.js.map