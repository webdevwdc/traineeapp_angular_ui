"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var google_marker_clusterer_1 = require("./../../models/google/google-marker-clusterer");
var google_info_window_1 = require("./../../models/google/google-info-window");
var core_1 = require("@angular/core");
var Observable_1 = require("rxjs/Observable");
var mapapiloader_1 = require("../mapapiloader");
var map_type_id_1 = require("../../models/map-type-id");
var marker_1 = require("../../models/marker");
var google_label_1 = require("../../models/google/google-label");
var google_polygon_1 = require("../../models/google/google-polygon");
var google_polyline_1 = require("../../models/google/google-polyline");
var google_conversions_1 = require("./google-conversions");
var google_marker_1 = require("./../../models/google/google-marker");
var google_events_lookup_1 = require("../../models/google/google-events-lookup");
/**
 * Concrete implementation of the MapService abstract implementing a Google Maps provider
 *
 * @export
 * @class GoogleMapService
 * @implements {MapService}
 */
var GoogleMapService = (function () {
    ///
    /// Constructor
    ///
    /**
     * Creates an instance of GoogleMapService.
     * @param {MapAPILoader} _loader MapAPILoader instance implemented for Google Maps. This instance will generally be injected.
     * @param {NgZone} _zone NgZone object to enable zone aware promises. This will generally be injected.
     *
     * @memberof GoogleMapService
     */
    function GoogleMapService(_loader, _zone) {
        var _this = this;
        this._loader = _loader;
        this._zone = _zone;
        this._map = new Promise(function (resolve) { _this._mapResolver = resolve; });
        this._config = this._loader.Config;
    }
    Object.defineProperty(GoogleMapService.prototype, "MapInstance", {
        ///
        /// Property Definitions
        ///
        /**
         * Gets the Google Map control instance underlying the implementation
         *
         * @readonly
         * @type {GoogleMapTypes.GoogleMap}
         * @memberof GoogleMapService
         */
        get: function () { return this._mapInstance; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapService.prototype, "MapPromise", {
        /**
         * Gets a Promise for a Google Map control instance underlying the implementation. Use this instead of {@link MapInstance} if you
         * are not sure if and when the instance will be created.
         * @readonly
         * @type {Promise<GoogleMapTypes.GoogleMap>}
         * @memberof GoogleMapService
         */
        get: function () { return this._map; },
        enumerable: true,
        configurable: true
    });
    ///
    /// Public methods and MapService interface implementation
    ///
    /*
     * Creates a Google map cluster layer within the map context
     *
     * @param {IClusterOptions} options - Options for the layer. See {@link IClusterOptions}.
     * @returns {Promise<Layer>} - Promise of a {@link Layer} object, which models the underlying Microsoft.Maps.ClusterLayer object.
     *
     * @memberof GoogleMapService
     */
    GoogleMapService.prototype.CreateClusterLayer = function (options) {
        return this._map.then(function (map) {
            var markerClusterer = new MarkerClusterer(map, [], options);
            return new google_marker_clusterer_1.GoogleMarkerClusterer(markerClusterer);
        });
    };
    /**
     * Creates an information window for a map position
     *
     * @param {IInfoWindowOptions} [options] - Infowindow options. See {@link IInfoWindowOptions}
     * @returns {Promise<InfoWindow>} - Promise of a {@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.
     *
     * @memberof GoogleMapService
     */
    GoogleMapService.prototype.CreateInfoWindow = function (options) {
        var _this = this;
        return this._map.then(function (map) {
            var o = google_conversions_1.GoogleConversions.TranslateInfoWindowOptions(options);
            var infoWindow = new google.maps.InfoWindow(o);
            return new google_info_window_1.GoogleInfoWindow(infoWindow, _this);
        });
    };
    /**
     * Creates a map layer within the map context
     *
     * @param {ILayerOptions} options - Options for the layer. See {@link ILayerOptions}
     * @returns {Promise<Layer>} - Promise of a {@link Layer} object, which models the underlying Microsoft.Maps.Layer object.
     *
     * @memberof GoogleMapService
     */
    GoogleMapService.prototype.CreateLayer = function (options) {
        return Promise.resolve({});
        // return this._map.then((map: GoogleMapTypes.GoogleMap) => {
        //     let layer: Microsoft.Maps.Layer = new Microsoft.Maps.Layer(options.id.toString());
        //     map.layers.insert(layer);
        //     return new GoogleLayer(layer, this);
        // });
    };
    /**
     * Creates a map instance
     *
     * @param {HTMLElement} el - HTML element to host the map.
     * @param {IMapOptions} mapOptions - Map options
     * @returns {Promise<void>} - Promise fullfilled once the map has been created.
     *
     * @memberof GoogleMapService
     */
    GoogleMapService.prototype.CreateMap = function (el, mapOptions) {
        var _this = this;
        return this._loader.Load().then(function () {
            google_label_1.ExtendMapLabelWithOverlayView();
            if (!mapOptions.mapTypeId == null) {
                mapOptions.mapTypeId = map_type_id_1.MapTypeId.hybrid;
            }
            var o = google_conversions_1.GoogleConversions.TranslateOptions(mapOptions);
            var map = new google.maps.Map(el, o);
            if (mapOptions.bounds) {
                map.fitBounds(google_conversions_1.GoogleConversions.TranslateBounds(mapOptions.bounds));
            }
            _this._mapResolver(map);
            return;
        });
    };
    /**
     * Creates a Google map marker within the map context
     *
     * @param {IMarkerOptions} [options=<IMarkerOptions>{}] - Options for the marker. See {@link IMarkerOptions}.
     * @returns {Promise<Marker>} - Promise of a {@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.
     *
     * @memberof GoogleMapService
     */
    GoogleMapService.prototype.CreateMarker = function (options) {
        if (options === void 0) { options = {}; }
        return this._map.then(function (map) {
            var payload = function (x) {
                var marker = new google.maps.Marker(x);
                marker.setMap(map);
                return new google_marker_1.GoogleMarker(marker);
            };
            var o = google_conversions_1.GoogleConversions.TranslateMarkerOptions(options);
            if (options.iconInfo && options.iconInfo.markerType) {
                var s = marker_1.Marker.CreateMarker(options.iconInfo);
                if (typeof (s) === 'string') {
                    o.icon = s;
                    return payload(o);
                }
                else {
                    return s.then(function (x) {
                        o.icon = x.icon;
                        return payload(o);
                    });
                }
            }
            else {
                return payload(o);
            }
        });
    };
    /**
     * Creates a polygon within the Google Map map context
     *
     * @abstract
     * @param {IPolygonOptions} options - Options for the polygon. See {@link IPolygonOptions}.
     * @returns {Promise<Polygon>} - Promise of a {@link Polygon} object, which models the underlying native polygon.
     *
     * @memberof MapService
     */
    GoogleMapService.prototype.CreatePolygon = function (options) {
        return this._map.then(function (map) {
            var o = google_conversions_1.GoogleConversions.TranslatePolygonOptions(options);
            var polygon = new google.maps.Polygon(o);
            polygon.setMap(map);
            var p = new google_polygon_1.GooglePolygon(polygon);
            if (options.title && options.title !== '') {
                p.Title = options.title;
            }
            if (options.showLabel != null) {
                p.ShowLabel = options.showLabel;
            }
            if (options.showTooltip != null) {
                p.ShowTooltip = options.showTooltip;
            }
            if (options.labelMaxZoom != null) {
                p.LabelMaxZoom = options.labelMaxZoom;
            }
            if (options.labelMinZoom != null) {
                p.LabelMinZoom = options.labelMinZoom;
            }
            return p;
        });
    };
    /**
     * Creates a polyline within the Google Map map context
     *
     * @abstract
     * @param {IPolylineOptions} options - Options for the polyline. See {@link IPolylineOptions}.
     * @returns {Promise<Polyline>} - Promise of a {@link Polyline} object (or an array therefore for complex paths)
     * which models the underlying native polyline.
     *
     * @memberof MapService
     */
    GoogleMapService.prototype.CreatePolyline = function (options) {
        var polyline;
        return this._map.then(function (map) {
            var o = google_conversions_1.GoogleConversions.TranslatePolylineOptions(options);
            if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {
                o.path = google_conversions_1.GoogleConversions.TranslatePaths(options.path)[0];
                polyline = new google.maps.Polyline(o);
                polyline.setMap(map);
                var pl = new google_polyline_1.GooglePolyline(polyline);
                if (options.title && options.title !== '') {
                    pl.Title = options.title;
                }
                if (options.showTooltip != null) {
                    pl.ShowTooltip = options.showTooltip;
                }
                return pl;
            }
            else {
                var paths = google_conversions_1.GoogleConversions.TranslatePaths(options.path);
                var lines_1 = new Array();
                paths.forEach(function (p) {
                    o.path = p;
                    polyline = new google.maps.Polyline(o);
                    polyline.setMap(map);
                    var pl = new google_polyline_1.GooglePolyline(polyline);
                    if (options.title && options.title !== '') {
                        pl.Title = options.title;
                    }
                    if (options.showTooltip != null) {
                        pl.ShowTooltip = options.showTooltip;
                    }
                    lines_1.push(pl);
                });
                return lines_1;
            }
        });
    };
    /**
     * Deletes a layer from the map.
     *
     * @param {Layer} layer - Layer to delete. See {@link Layer}. This method expects the Google specific Layer model implementation.
     * @returns {Promise<void>} - Promise fullfilled when the layer has been removed.
     *
     * @memberof GoogleMapService
     */
    GoogleMapService.prototype.DeleteLayer = function (layer) {
        return Promise.resolve();
        // return this._map.then((map: GoogleMapTypes.GoogleMap) => {
        //     map.layers.remove(layer.NativePrimitve);
        // });
    };
    /**
     * Dispaose the map and associated resoures.
     *
     * @returns {void}
     *
     * @memberof GoogleMapService
     */
    GoogleMapService.prototype.DisposeMap = function () {
        var _this = this;
        if (this._map == null && this._mapInstance == null) {
            return;
        }
        if (this._mapInstance != null) {
            this._mapInstance = null;
            this._map = new Promise(function (resolve) { _this._mapResolver = resolve; });
        }
    };
    /**
     * Gets the geo coordinates of the map center
     *
     * @returns {Promise<ILatLong>} - A promise that when fullfilled contains the goe location of the center. See {@link ILatLong}.
     *
     * @memberof GoogleMapService
     */
    GoogleMapService.prototype.GetCenter = function () {
        return this._map.then(function (map) {
            var center = map.getCenter();
            return {
                latitude: center.lat(),
                longitude: center.lng()
            };
        });
    };
    /**
     * Gets the geo coordinates of the map bounding box
     *
     * @returns {Promise<IBox>} - A promise that when fullfilled contains the geo location of the bounding box. See {@link IBox}.
     *
     * @memberof GoogleMapService
     */
    GoogleMapService.prototype.GetBounds = function () {
        return this._map.then(function (map) {
            var box = map.getBounds();
            return {
                maxLatitude: Math.max(box.getNorthEast().lat(), box.getSouthWest().lat()),
                maxLongitude: Math.max(box.getNorthEast().lng(), box.getSouthWest().lng()),
                minLatitude: Math.min(box.getNorthEast().lat(), box.getSouthWest().lat()),
                minLongitude: Math.min(box.getNorthEast().lng(), box.getSouthWest().lng()),
                center: { latitude: box.getCenter().lat(), longitude: box.getCenter().lng() },
                padding: 0
            };
        });
    };
    /**
     * Gets the current zoom level of the map.
     *
     * @returns {Promise<number>} - A promise that when fullfilled contains the zoom level.
     *
     * @memberof GoogleMapService
     */
    GoogleMapService.prototype.GetZoom = function () {
        return this._map.then(function (map) { return map.getZoom(); });
    };
    /**
     * Provides a conversion of geo coordinates to pixels on the map control.
     *
     * @param {ILatLong} loc - The geo coordinates to translate.
     * @returns {Promise<IPoint>} - Promise of an {@link IPoint} interface representing the pixels. This promise resolves to null
     * if the goe coordinates are not in the view port.
     *
     * @memberof GoogleMapService
     */
    GoogleMapService.prototype.LocationToPoint = function (loc) {
        return this._map.then(function (m) {
            // let l: Microsoft.Maps.Location = GoogleConversions.TranslateLocation(loc);
            // let p: Microsoft.Maps.Point = <Microsoft.Maps.Point>m.tryLocationToPixel(l, Microsoft.Maps.PixelReference.control);
            // if (p != null) return { x: p.x, y: p.y };
            return null;
        });
    };
    /**
     * Centers the map on a geo location.
     *
     * @param {ILatLong} latLng - GeoCoordinates around which to center the map. See {@link ILatLong}
     * @returns {Promise<void>} - Promise that is fullfilled when the center operations has been completed.
     *
     * @memberof GoogleMapService
     */
    GoogleMapService.prototype.SetCenter = function (latLng) {
        return this._map.then(function (map) {
            var center = google_conversions_1.GoogleConversions.TranslateLocationObject(latLng);
            map.setCenter(center);
        });
    };
    /**
     * Sets the generic map options.
     *
     * @param {IMapOptions} options - Options to set.
     *
     * @memberof GoogleMapService
     */
    GoogleMapService.prototype.SetMapOptions = function (options) {
        this._map.then(function (m) {
            var o = google_conversions_1.GoogleConversions.TranslateOptions(options);
            m.setOptions(o);
        });
    };
    /**
     * Sets the view options of the map.
     *
     * @param {IMapOptions} options - Options to set.
     *
     * @memberof GoogleMapService
     */
    GoogleMapService.prototype.SetViewOptions = function (options) {
        this._map.then(function (m) {
            if (options.bounds) {
                m.fitBounds(google_conversions_1.GoogleConversions.TranslateBounds(options.bounds));
            }
            var o = google_conversions_1.GoogleConversions.TranslateOptions(options);
            m.setOptions(o);
        });
    };
    /**
     * Sets the zoom level of the map.
     *
     * @param {number} zoom - Zoom level to set.
     * @returns {Promise<void>} - A Promise that is fullfilled once the zoom operation is complete.
     *
     * @memberof GoogleMapService
     */
    GoogleMapService.prototype.SetZoom = function (zoom) {
        return this._map.then(function (map) { return map.setZoom(zoom); });
    };
    /**
     * Creates an event subscription
     *
     * @template E - Generic type of the underlying event.
     * @param {string} eventName - The name of the event (e.g. 'click')
     * @returns {Observable<E>} - An observable of type E that fires when the event occurs.
     *
     * @memberof GoogleMapService
     */
    GoogleMapService.prototype.SubscribeToMapEvent = function (eventName) {
        var _this = this;
        var googleEventName = google_events_lookup_1.GoogleMapEventsLookup[eventName];
        return Observable_1.Observable.create(function (observer) {
            _this._map.then(function (m) {
                m.addListener(googleEventName, function (e) {
                    _this._zone.run(function () { return observer.next(e); });
                });
            });
        });
    };
    /**
     * Triggers the given event name on the map instance.
     *
     * @param {string} eventName - Event to trigger.
     * @returns {Promise<void>} - A promise that is fullfilled once the event is triggered.
     *
     * @memberof GoogleMapService
     */
    GoogleMapService.prototype.TriggerMapEvent = function (eventName) {
        return this._map.then(function (m) { return google.maps.event.trigger(m, eventName, null); });
    };
    return GoogleMapService;
}());
GoogleMapService.decorators = [
    { type: core_1.Injectable },
];
/** @nocollapse */
GoogleMapService.ctorParameters = function () { return [
    { type: mapapiloader_1.MapAPILoader, },
    { type: core_1.NgZone, },
]; };
exports.GoogleMapService = GoogleMapService;
//# sourceMappingURL=google-map.service.js.map