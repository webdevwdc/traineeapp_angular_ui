"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var Observable_1 = require("rxjs/Observable");
var map_marker_1 = require("../../components/map-marker");
var map_service_1 = require("../map.service");
var layer_service_1 = require("../layer.service");
var cluster_service_1 = require("../cluster.service");
var google_conversions_1 = require("./google-conversions");
/**
 * Concrete implementation of the MarkerService abstract class for Google.
 *
 * @export
 * @class GoogleMarkerService
 * @implements {MarkerService}
 */
var GoogleMarkerService = (function () {
    ///
    /// Constructor
    ///
    /**
     * Creates an instance of GoogleMarkerService.
     * @param {MapService} _mapService - {@link MapService} instance.
     * The concrete {@link GoogleMapService} implementation is expected.
     * @param {LayerService} _layerService - {@link LayerService} instance.
     * The concrete {@link GoogleLayerService} implementation is expected.
     * @param {ClusterService} _clusterService - {@link ClusterService} instance.
     * The concrete {@link GoogleClusterService} implementation is expected.
     * @param {NgZone} _zone - NgZone instance to support zone aware promises.
     *
     * @memberof GoogleMarkerService
     */
    function GoogleMarkerService(_mapService, _layerService, _clusterService, _zone) {
        this._mapService = _mapService;
        this._layerService = _layerService;
        this._clusterService = _clusterService;
        this._zone = _zone;
        ///
        /// Field declarations
        ///
        this._markers = new Map();
    }
    /**
     * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.
     *
     * @abstract
     * @param {MapMarkerDirective} marker - The {@link MapMarkerDirective} to be added.
     *
     * @memberof MarkerService
     */
    GoogleMarkerService.prototype.AddMarker = function (marker) {
        var o = {
            anchor: marker.Anchor,
            position: { latitude: marker.Latitude, longitude: marker.Longitude },
            title: marker.Title,
            label: marker.Label,
            draggable: marker.Draggable,
            icon: marker.IconUrl,
            iconInfo: marker.IconInfo,
            width: marker.Width,
            height: marker.Height,
            isFirst: marker.IsFirstInSet,
            isLast: marker.IsLastInSet
        };
        // create marker via promise.
        var markerPromise = null;
        if (marker.InClusterLayer) {
            markerPromise = this._clusterService.CreateMarker(marker.LayerId, o);
        }
        else if (marker.InCustomLayer) {
            markerPromise = this._layerService.CreateMarker(marker.LayerId, o);
        }
        else {
            markerPromise = this._mapService.CreateMarker(o);
        }
        this._markers.set(marker, markerPromise);
        if (marker.IconInfo) {
            markerPromise.then(function (m) {
                // update iconInfo to provide hook to do post icon creation activities and
                // also re-anchor the marker
                marker.DynamicMarkerCreated.emit(o.iconInfo);
                var p = {
                    x: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.width * o.iconInfo.markerOffsetRatio.x) : 0,
                    y: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.height * o.iconInfo.markerOffsetRatio.y) : 0,
                };
                m.SetAnchor(p);
            });
        }
    };
    ;
    /**
     * Registers an event delegate for a marker.
     *
     * @abstract
     * @template T - Type of the event to emit.
     * @param {string} eventName - The name of the event to register (e.g. 'click')
     * @param {MapMarkerDirective} marker - The {@link MapMarkerDirective} for which to register the event.
     * @returns {Observable<T>} - Observable emiting an instance of T each time the event occurs.
     *
     * @memberof MarkerService
     */
    GoogleMarkerService.prototype.CreateEventObservable = function (eventName, marker) {
        var _this = this;
        return Observable_1.Observable.create(function (observer) {
            _this._markers.get(marker).then(function (m) {
                m.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
            });
        });
    };
    ;
    /**
     * Deletes a marker.
     *
     * @abstract
     * @param {MapMarkerDirective} marker - {@link MapMarkerDirective} to be deleted.
     * @returns {Promise<void>} - A promise fullfilled once the marker has been deleted.
     *
     * @memberof MarkerService
     */
    GoogleMarkerService.prototype.DeleteMarker = function (marker) {
        var _this = this;
        var m = this._markers.get(marker);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then(function (ma) {
            return _this._zone.run(function () {
                ma.DeleteMarker();
                _this._markers.delete(marker);
            });
        });
    };
    ;
    /**
     * Obtains geo coordinates for the marker on the click location
     *
     * @abstract
     * @param {(MouseEvent| any)} e - The mouse event.
     * @returns {ILatLong} - {@link ILatLong} containing the geo coordinates of the clicked marker.
     *
     * @memberof MarkerService
     */
    GoogleMarkerService.prototype.GetCoordinatesFromClick = function (e) {
        if (!e) {
            return null;
        }
        if (!e.latLng) {
            return null;
        }
        if (!e.latLng.lat || !e.latLng.lng) {
            return null;
        }
        return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };
    };
    ;
    /**
     * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
     *
     * @abstract
     * @param {MapMarkerDirective} marker - The {@link MapMarkerDirective} for which to obtain the marker model.
     * @returns {Promise<Marker>} - A promise that when fullfilled contains the {@link Marker} implementation of the underlying platform.
     *
     * @memberof MarkerService
     */
    GoogleMarkerService.prototype.GetNativeMarker = function (marker) {
        return this._markers.get(marker);
    };
    ;
    /**
     * Obtains the marker pixel location for the marker on the click location
     *
     * @abstract
     * @param {(MouseEvent| any)} e - The mouse event.
     * @returns {IPoint} - {@link ILatLong} containing the pixels of the marker on the map canvas.
     *
     * @memberof MarkerService
     */
    GoogleMarkerService.prototype.GetPixelsFromClick = function (e) {
        return { x: 0, y: 0 };
    };
    ;
    /**
     * Converts a geo location to a pixel location relative to the map canvas.
     *
     * @abstract
     * @param {(MapMarkerDirective | ILatLong)} target - Either a {@link MapMarkerDirective}
     * or a {@link ILatLong} for the basis of translation.
     * @returns {Promise<IPoint>} - A promise that when fullfilled contains a {@link IPoint}
     * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.
     *
     * @memberof MarkerService
     */
    GoogleMarkerService.prototype.LocationToPoint = function (target) {
        var _this = this;
        if (target == null) {
            return Promise.resolve(null);
        }
        if (target instanceof map_marker_1.MapMarkerDirective) {
            return this._markers.get(target).then(function (m) {
                var l = m.Location;
                var p = _this._mapService.LocationToPoint(l);
                return p;
            });
        }
        return this._mapService.LocationToPoint(target);
    };
    ;
    /**
     * Updates the anchor position for the marker.
     *
     * @abstract
     * @param {MapMarkerDirective} - The {@link MapMarkerDirective} object for which to upate the anchor.
     * Anchor information is present in the underlying {@link Marker} model object.
     * @returns {Promise<void>} - A promise that is fullfilled when the anchor position has been updated.
     *
     * @memberof MarkerService
     */
    GoogleMarkerService.prototype.UpdateAnchor = function (marker) {
        return this._markers.get(marker).then(function (m) {
            m.SetAnchor(marker.Anchor);
        });
    };
    ;
    /**
     * Updates whether the marker is draggable.
     *
     * @abstract
     * @param {MapMarkerDirective} - The {@link MapMarkerDirective} object for which to upate dragability.
     * Dragability information is present in the underlying {@link Marker} model object.
     * @returns {Promise<void>} - A promise that is fullfilled when the marker has been updated.
     *
     * @memberof MarkerService
     */
    GoogleMarkerService.prototype.UpdateDraggable = function (marker) {
        return this._markers.get(marker).then(function (m) { return m.SetDraggable(marker.Draggable); });
    };
    ;
    /**
     * Updates the Icon on the marker.
     *
     * @abstract
     * @param {MapMarkerDirective} - The {@link MapMarkerDirective} object for which to upate the icon. Icon information is present
     * in the underlying {@link Marker} model object.
     * @returns {Promise<void>} - A promise that is fullfilled when the icon information has been updated.
     *
     * @memberof MarkerService
     */
    GoogleMarkerService.prototype.UpdateIcon = function (marker) {
        return this._markers.get(marker).then(function (m) {
            if (marker.IconInfo) {
                var x = {
                    position: { latitude: marker.Latitude, longitude: marker.Longitude },
                    iconInfo: marker.IconInfo
                };
                var o = google_conversions_1.GoogleConversions.TranslateMarkerOptions(x);
                m.SetIcon(o.icon);
                marker.DynamicMarkerCreated.emit(x.iconInfo);
            }
            else {
                m.SetIcon(marker.IconUrl);
            }
        });
    };
    ;
    /**
     * Updates the label on the marker.
     *
     * @abstract
     * @param {MapMarkerDirective} - The {@link MapMarkerDirective} object for which to upate the label.
     * Label information is present in the underlying {@link Marker} model object.
     * @returns {Promise<void>} - A promise that is fullfilled when the label has been updated.
     *
     * @memberof MarkerService
     */
    GoogleMarkerService.prototype.UpdateLabel = function (marker) {
        return this._markers.get(marker).then(function (m) { m.SetLabel(marker.Label); });
    };
    ;
    /**
     * Updates the geo coordinates for the marker.
     *
     * @abstract
     * @param {MapMarkerDirective} - The {@link MapMarkerDirective} object for which to upate the coordinates.
     * Coordinate information is present in the underlying {@link Marker} model object.
     * @returns {Promise<void>} - A promise that is fullfilled when the position has been updated.
     *
     * @memberof MarkerService
     */
    GoogleMarkerService.prototype.UpdateMarkerPosition = function (marker) {
        return this._markers.get(marker).then(function (m) { return m.SetPosition({
            latitude: marker.Latitude,
            longitude: marker.Longitude
        }); });
    };
    ;
    /**
     * Updates the title on the marker.
     *
     * @abstract
     * @param {MapMarkerDirective} - The {@link MapMarkerDirective} object for which to upate the title.
     * Title information is present in the underlying {@link Marker} model object.
     * @returns {Promise<void>} - A promise that is fullfilled when the title has been updated.
     *
     * @memberof MarkerService
     */
    GoogleMarkerService.prototype.UpdateTitle = function (marker) {
        return this._markers.get(marker).then(function (m) { return m.SetTitle(marker.Title); });
    };
    ;
    /**
     * Updates the visibility on the marker.
     *
     * @abstract
     * @param {MapMarkerDirective} - The {@link MapMarkerDirective} object for which to upate the title.
     * Title information is present in the underlying {@link Marker} model object.
     * @returns {Promise<void>} - A promise that is fullfilled when the title has been updated.
     *
     * @memberof MarkerService
     */
    GoogleMarkerService.prototype.UpdateVisible = function (marker) {
        return this._markers.get(marker).then(function (m) { return m.SetVisible(marker.Visible); });
    };
    ;
    return GoogleMarkerService;
}());
GoogleMarkerService.decorators = [
    { type: core_1.Injectable },
];
/** @nocollapse */
GoogleMarkerService.ctorParameters = function () { return [
    { type: map_service_1.MapService, },
    { type: layer_service_1.LayerService, },
    { type: cluster_service_1.ClusterService, },
    { type: core_1.NgZone, },
]; };
exports.GoogleMarkerService = GoogleMarkerService;
//# sourceMappingURL=google-marker.service.js.map